
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=createProduct_40b34e72f1
ROOST_METHOD_SIG_HASH=createProduct_7b3ca706e7

Scenario 1: Successfully Create a Product with Valid Data

Details:
  TestName: createProductWithValidData
  Description: Verify that a product with valid name, positive price, and non-negative stock is successfully created and saved to the repository.

Execution:
  Arrange: Create a Product object with a valid name (e.g., "Test Product"), a positive price (e.g., BigDecimal.valueOf(10.99)), and a non-negative stock (e.g., 100). Mock the productRepository.save() method to return the same product.
  Act: Invoke createProduct() method with the valid product.
  Assert: Verify that the returned product is not null and matches the input product. Verify that productRepository.save() was called exactly once with the product.

Validation:
  This assertion verifies that the method correctly saves a valid product to the repository and returns the saved product. This is the primary happy path scenario ensuring the core functionality works as expected.

---

Scenario 2: Throw Exception When Product Name is Null

Details:
  TestName: createProductWithNullNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with a null name.

Execution:
  Arrange: Create a Product object with name set to null, a valid price (e.g., BigDecimal.valueOf(10.00)), and valid stock (e.g., 50).
  Act: Invoke createProduct() method with the product having null name.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product name cannot be empty".

Validation:
  This assertion ensures that the validation logic correctly rejects products with null names. This is critical for data integrity as product names are required fields in the business domain.

---

Scenario 3: Throw Exception When Product Name is Empty String

Details:
  TestName: createProductWithEmptyNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with an empty string as name.

Execution:
  Arrange: Create a Product object with name set to "" (empty string), a valid price, and valid stock.
  Act: Invoke createProduct() method with the product having empty name.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product name cannot be empty".

Validation:
  This assertion validates that empty strings are not accepted as valid product names. This prevents creation of products with meaningless names.

---

Scenario 4: Throw Exception When Product Name Contains Only Whitespace

Details:
  TestName: createProductWithWhitespaceOnlyNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with a name containing only whitespace characters.

Execution:
  Arrange: Create a Product object with name set to "   " (whitespace only), a valid price, and valid stock.
  Act: Invoke createProduct() method with the product having whitespace-only name.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product name cannot be empty".

Validation:
  This assertion ensures that whitespace-only names are treated as invalid. The trim() method is used in validation, so names with only spaces should be rejected.

---

Scenario 5: Throw Exception When Product Price is Null

Details:
  TestName: createProductWithNullPriceThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with a null price.

Execution:
  Arrange: Create a Product object with a valid name, price set to null, and valid stock.
  Act: Invoke createProduct() method with the product having null price.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product price must be a positive value".

Validation:
  This assertion ensures that products cannot be created without a price. Price is a mandatory field for any product in the system.

---

Scenario 6: Throw Exception When Product Price is Negative

Details:
  TestName: createProductWithNegativePriceThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with a negative price.

Execution:
  Arrange: Create a Product object with a valid name, price set to BigDecimal.valueOf(-5.00), and valid stock.
  Act: Invoke createProduct() method with the product having negative price.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product price must be a positive value".

Validation:
  This assertion validates that negative prices are not allowed. Products cannot have negative prices in any valid business scenario.

---

Scenario 7: Successfully Create Product with Zero Price

Details:
  TestName: createProductWithZeroPriceSucceeds
  Description: Verify that a product with zero price is successfully created (e.g., for free products or promotional items).

Execution:
  Arrange: Create a Product object with a valid name, price set to BigDecimal.ZERO, and valid stock. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the product having zero price.
  Assert: Verify that the product is saved successfully and returned.

Validation:
  This assertion confirms that zero price is considered valid (not negative). This allows for free products or promotional items in the system.

---

Scenario 8: Throw Exception When Product Stock is Null

Details:
  TestName: createProductWithNullStockThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with null stock.

Execution:
  Arrange: Create a Product object with a valid name, valid price, and stock set to null.
  Act: Invoke createProduct() method with the product having null stock.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product stock cannot be negative".

Validation:
  This assertion ensures that stock quantity must be explicitly provided. Null stock values are not acceptable for inventory management.

---

Scenario 9: Throw Exception When Product Stock is Negative

Details:
  TestName: createProductWithNegativeStockThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a product with negative stock.

Execution:
  Arrange: Create a Product object with a valid name, valid price, and stock set to -10.
  Act: Invoke createProduct() method with the product having negative stock.
  Assert: Assert that an IllegalArgumentException is thrown with the message "Product stock cannot be negative".

Validation:
  This assertion validates that negative stock quantities are not allowed. Inventory cannot be negative in a real-world scenario.

---

Scenario 10: Successfully Create Product with Zero Stock

Details:
  TestName: createProductWithZeroStockSucceeds
  Description: Verify that a product with zero stock is successfully created (e.g., out-of-stock or pre-order items).

Execution:
  Arrange: Create a Product object with a valid name, valid price, and stock set to 0. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the product having zero stock.
  Assert: Verify that the product is saved successfully and returned.

Validation:
  This assertion confirms that zero stock is a valid value. This allows for creating products that are temporarily out of stock or available for pre-order.

---

Scenario 11: Successfully Create Product with Large Stock Value

Details:
  TestName: createProductWithLargeStockValue
  Description: Verify that a product with a very large stock value is successfully created.

Execution:
  Arrange: Create a Product object with a valid name, valid price, and stock set to Integer.MAX_VALUE. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the product having maximum integer stock.
  Assert: Verify that the product is saved successfully and returned.

Validation:
  This assertion tests the boundary condition for stock values, ensuring the system can handle large inventory quantities without issues.

---

Scenario 12: Successfully Create Product with High Precision Price

Details:
  TestName: createProductWithHighPrecisionPrice
  Description: Verify that a product with a high precision decimal price is successfully created.

Execution:
  Arrange: Create a Product object with a valid name, price set to new BigDecimal("99.99"), and valid stock. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the product.
  Assert: Verify that the product is saved successfully with the exact price value preserved.

Validation:
  This assertion ensures that BigDecimal prices with decimal precision are handled correctly, which is important for accurate financial calculations.

---

Scenario 13: Verify Repository Save Method is Called

Details:
  TestName: createProductCallsRepositorySave
  Description: Verify that the productRepository.save() method is invoked exactly once when creating a valid product.

Execution:
  Arrange: Create a valid Product object. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the valid product.
  Assert: Verify using mock verification that productRepository.save() was called exactly once with the correct product argument.

Validation:
  This assertion confirms the interaction between the service and repository layers, ensuring proper delegation of persistence operations.

---

Scenario 14: Create Product with Name Having Leading and Trailing Spaces

Details:
  TestName: createProductWithNameHavingLeadingTrailingSpaces
  Description: Verify that a product with a name containing leading and trailing spaces (but non-empty after trim) is successfully created.

Execution:
  Arrange: Create a Product object with name set to "  Valid Product  ", valid price, and valid stock. Mock productRepository.save() to return the product.
  Act: Invoke createProduct() method with the product.
  Assert: Verify that the product is saved successfully.

Validation:
  This assertion confirms that names with surrounding whitespace but valid content are accepted. The validation uses trim() to check for empty names, so "  Valid  " should pass validation.

*/

// ********RoostGPT********

package com.example.demo.service;

import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.math.BigDecimal;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@ExtendWith(MockitoExtension.class)
class ProductServiceImplCreateProductTest {

	@Mock
	private ProductRepository productRepository;

	private ProductServiceImpl productService;

	@BeforeEach
	void setUp() {
		productService = new ProductServiceImpl(productRepository);
	}

	@Test
	@Tag("valid")
	void createProductWithValidData() {
		// Arrange
		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(10.99));
		product.setStock(100);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals("Test Product", result.getName());
		assertEquals(BigDecimal.valueOf(10.99), result.getPrice());
		assertEquals(100, result.getStock());
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("invalid")
	void createProductWithNullNameThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName(null);
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(50);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product name cannot be empty", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("invalid")
	void createProductWithEmptyNameThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(50);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product name cannot be empty", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("invalid")
	void createProductWithWhitespaceOnlyNameThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("   ");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(50);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product name cannot be empty", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("invalid")
	void createProductWithNullPriceThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("Valid Product");
		product.setPrice(null);
		product.setStock(50);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product price must be a positive value", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("invalid")
	void createProductWithNegativePriceThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("Valid Product");
		product.setPrice(BigDecimal.valueOf(-5.00));
		product.setStock(50);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product price must be a positive value", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("boundary")
	void createProductWithZeroPriceSucceeds() {
		// Arrange
		Product product = new Product();
		product.setName("Free Product");
		product.setPrice(BigDecimal.ZERO);
		product.setStock(50);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals(BigDecimal.ZERO, result.getPrice());
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("invalid")
	void createProductWithNullStockThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("Valid Product");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(null);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product stock cannot be negative", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("invalid")
	void createProductWithNegativeStockThrowsException() {
		// Arrange
		Product product = new Product();
		product.setName("Valid Product");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(-10);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.createProduct(product));
		assertEquals("Product stock cannot be negative", exception.getMessage());
		verify(productRepository, never()).save(any());
	}

	@Test
	@Tag("boundary")
	void createProductWithZeroStockSucceeds() {
		// Arrange
		Product product = new Product();
		product.setName("Out of Stock Product");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(0);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals(0, result.getStock());
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("boundary")
	void createProductWithLargeStockValue() {
		// Arrange
		Product product = new Product();
		product.setName("High Stock Product");
		product.setPrice(BigDecimal.valueOf(10.00));
		product.setStock(Integer.MAX_VALUE);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals(Integer.MAX_VALUE, result.getStock());
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("valid")
	void createProductWithHighPrecisionPrice() {
		// Arrange
		Product product = new Product();
		product.setName("Precision Price Product");
		product.setPrice(new BigDecimal("99.99"));
		product.setStock(50);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals(new BigDecimal("99.99"), result.getPrice());
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("integration")
	void createProductCallsRepositorySave() {
		// Arrange
		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(25.00));
		product.setStock(75);
		when(productRepository.save(product)).thenReturn(product);
		// Act
		productService.createProduct(product);
		// Assert
		verify(productRepository, times(1)).save(product);
	}

	@Test
	@Tag("valid")
	void createProductWithNameHavingLeadingTrailingSpaces() {
		// Arrange
		Product product = new Product();
		product.setName("  Valid Product  ");
		product.setPrice(BigDecimal.valueOf(15.00));
		product.setStock(30);
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.createProduct(product);
		// Assert
		assertNotNull(result);
		assertEquals("  Valid Product  ", result.getName());
		verify(productRepository, times(1)).save(product);
	}

}