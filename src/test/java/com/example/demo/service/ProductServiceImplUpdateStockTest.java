
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=updateStock_ffc95394cf
ROOST_METHOD_SIG_HASH=updateStock_5360f31553

Scenario 1: Successfully Increase Stock with Positive Quantity

Details:
  TestName: updateStockWithPositiveQuantityIncreasesStock
  Description: Verify that when a positive quantity is provided, the product's stock is increased by calling the increaseStock method and the updated product is saved and returned.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called with the given id
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and a positive quantity (e.g., 10)
  Assert:
    - Verify that findById was called with the correct id
    - Verify that increaseStock was called on the product with the positive quantity
    - Verify that save was called with the product
    - Assert that the returned product is not null

Validation:
  This test verifies that the method correctly handles positive quantities by invoking the increaseStock method on the product. This is essential for inventory management when adding new stock to existing products.

---

Scenario 2: Successfully Decrease Stock with Negative Quantity

Details:
  TestName: updateStockWithNegativeQuantityDecreasesStock
  Description: Verify that when a negative quantity is provided, the product's stock is decreased by calling the decreaseStock method with the absolute value of the quantity.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called with the given id
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and a negative quantity (e.g., -5)
  Assert:
    - Verify that findById was called with the correct id
    - Verify that decreaseStock was called on the product with the absolute value (5)
    - Verify that save was called with the product
    - Assert that the returned product is not null

Validation:
  This test ensures that negative quantities are properly converted to their absolute values and used to decrease stock. This is critical for processing sales or inventory reductions.

---

Scenario 3: No Stock Change When Quantity is Zero

Details:
  TestName: updateStockWithZeroQuantityDoesNotChangeStock
  Description: Verify that when quantity is zero, neither increaseStock nor decreaseStock is called, but the product is still saved and returned.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called with the given id
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and quantity of 0
  Assert:
    - Verify that findById was called with the correct id
    - Verify that neither increaseStock nor decreaseStock was called on the product
    - Verify that save was called with the product
    - Assert that the returned product is not null

Validation:
  This test confirms that a zero quantity does not modify the stock but still persists the product. This handles edge cases where an update operation is called with no actual change.

---

Scenario 4: Throw Exception When Product Not Found

Details:
  TestName: updateStockThrowsExceptionWhenProductNotFound
  Description: Verify that an IllegalArgumentException is thrown when attempting to update stock for a product id that does not exist in the repository.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Configure the mock to return an empty Optional when findById is called with a non-existent id
  Act:
    - Call updateStock with a non-existent product id and any quantity
  Assert:
    - Assert that an IllegalArgumentException is thrown
    - Verify that the exception message contains "Product not found with id:"
    - Verify that save was never called

Validation:
  This test ensures proper error handling when a product cannot be found. It validates that the system fails gracefully with a meaningful error message, preventing operations on non-existent products.

---

Scenario 5: Update Stock with Large Positive Quantity

Details:
  TestName: updateStockWithLargePositiveQuantity
  Description: Verify that the method correctly handles large positive quantities without overflow or errors.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and a large positive quantity (e.g., Integer.MAX_VALUE - 1)
  Assert:
    - Verify that increaseStock was called with the large quantity
    - Verify that save was called
    - Assert that the returned product is not null

Validation:
  This test validates that the system can handle boundary conditions with large stock increases, ensuring robustness in high-volume inventory scenarios.

---

Scenario 6: Update Stock with Large Negative Quantity

Details:
  TestName: updateStockWithLargeNegativeQuantity
  Description: Verify that the method correctly handles large negative quantities by converting to absolute value and calling decreaseStock.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and a large negative quantity (e.g., Integer.MIN_VALUE + 1)
  Assert:
    - Verify that decreaseStock was called with the absolute value of the quantity
    - Verify that save was called
    - Assert that the returned product is not null

Validation:
  This test ensures that large negative values are properly handled using Math.abs() and that the system remains stable under extreme input conditions.

---

Scenario 7: Update Stock with Null Product Id

Details:
  TestName: updateStockWithNullIdThrowsException
  Description: Verify that the method properly handles a null product id by throwing an appropriate exception from the repository layer.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Configure the mock to return an empty Optional or throw an exception when findById is called with null
  Act:
    - Call updateStock with null as the product id and any quantity
  Assert:
    - Assert that an exception is thrown (either IllegalArgumentException or NullPointerException depending on repository behavior)
    - Verify that save was never called

Validation:
  This test validates input validation for null product identifiers, ensuring the system handles invalid inputs gracefully and prevents null pointer exceptions in downstream operations.

---

Scenario 8: Verify Product is Saved After Stock Increase

Details:
  TestName: updateStockSavesProductAfterIncrease
  Description: Verify that after increasing stock, the modified product is persisted to the repository and the saved product is returned.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return a specific Product instance when save is called
  Act:
    - Call updateStock with the product id and a positive quantity
  Assert:
    - Verify that save was called exactly once
    - Assert that the returned product matches the one returned by save

Validation:
  This test confirms the persistence behavior of the method, ensuring that stock changes are properly saved to the database and the updated entity is returned to the caller.

---

Scenario 9: Verify Product is Saved After Stock Decrease

Details:
  TestName: updateStockSavesProductAfterDecrease
  Description: Verify that after decreasing stock, the modified product is persisted to the repository and the saved product is returned.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return a specific Product instance when save is called
  Act:
    - Call updateStock with the product id and a negative quantity
  Assert:
    - Verify that save was called exactly once
    - Assert that the returned product matches the one returned by save

Validation:
  This test ensures that stock decreases are properly persisted, which is critical for maintaining accurate inventory records after sales or adjustments.

---

Scenario 10: Update Stock with Quantity of One

Details:
  TestName: updateStockWithQuantityOfOneIncreasesStock
  Description: Verify that the minimum positive quantity (1) correctly triggers the increaseStock method.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and quantity of 1
  Assert:
    - Verify that increaseStock was called with quantity 1
    - Verify that save was called
    - Assert that the returned product is not null

Validation:
  This test validates the boundary condition for the smallest positive stock change, ensuring that even single-unit increases are processed correctly.

---

Scenario 11: Update Stock with Quantity of Negative One

Details:
  TestName: updateStockWithQuantityOfNegativeOneDecreasesStock
  Description: Verify that the minimum negative quantity (-1) correctly triggers the decreaseStock method with absolute value 1.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create a Product instance with a known id
    - Configure the mock to return the Product when findById is called
    - Configure the mock to return the Product when save is called
  Act:
    - Call updateStock with the product id and quantity of -1
  Assert:
    - Verify that decreaseStock was called with quantity 1
    - Verify that save was called
    - Assert that the returned product is not null

Validation:
  This test validates the boundary condition for the smallest negative stock change, ensuring that single-unit decreases are processed correctly through the absolute value conversion.

*/

// ********RoostGPT********

package com.example.demo.service;

import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.math.BigDecimal;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Service;
import java.util.List;

@ExtendWith(MockitoExtension.class)
class ProductServiceImplUpdateStockTest {

	@Mock
	private ProductRepository productRepository;

	private ProductServiceImpl productService;

	@BeforeEach
	void setUp() {
		productService = new ProductServiceImpl(productRepository);
	}

	@Test
	@Tag("valid")
	void updateStockWithPositiveQuantityIncreasesStock() {
		// Arrange
		Long productId = 1L;
		int quantity = 10;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(productRepository).findById(productId);
		verify(product).increaseStock(quantity);
		verify(productRepository).save(product);
	}

	@Test
	@Tag("valid")
	void updateStockWithNegativeQuantityDecreasesStock() {
		// Arrange
		Long productId = 1L;
		int quantity = -5;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(productRepository).findById(productId);
		verify(product).decreaseStock(Math.abs(quantity));
		verify(productRepository).save(product);
	}

	@Test
	@Tag("boundary")
	void updateStockWithZeroQuantityDoesNotChangeStock() {
		// Arrange
		Long productId = 1L;
		int quantity = 0;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(productRepository).findById(productId);
		verify(product, never()).increaseStock(anyInt());
		verify(product, never()).decreaseStock(anyInt());
		verify(productRepository).save(product);
	}

	@Test
	@Tag("invalid")
	void updateStockThrowsExceptionWhenProductNotFound() {
		// Arrange
		Long nonExistentId = 999L;
		int quantity = 10;
		when(productRepository.findById(nonExistentId)).thenReturn(Optional.empty());
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.updateStock(nonExistentId, quantity));
		assertTrue(exception.getMessage().contains("Product not found with id:"));
		verify(productRepository).findById(nonExistentId);
		verify(productRepository, never()).save(any(Product.class));
	}

	@Test
	@Tag("boundary")
	void updateStockWithLargePositiveQuantity() {
		// Arrange
		Long productId = 1L;
		int quantity = Integer.MAX_VALUE - 1;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(0);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(product).increaseStock(quantity);
		verify(productRepository).save(product);
	}

	@Test
	@Tag("boundary")
	void updateStockWithLargeNegativeQuantity() {
		// Arrange
		Long productId = 1L;
		int quantity = Integer.MIN_VALUE + 1;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(Integer.MAX_VALUE);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(product).decreaseStock(Math.abs(quantity));
		verify(productRepository).save(product);
	}

	@Test
	@Tag("invalid")
	void updateStockWithNullIdThrowsException() {
		// Arrange
		Long nullId = null;
		int quantity = 10;
		when(productRepository.findById(nullId)).thenReturn(Optional.empty());
		// Act & Assert
		assertThrows(Exception.class, () -> productService.updateStock(nullId, quantity));
		verify(productRepository, never()).save(any(Product.class));
	}

	@Test
	@Tag("valid")
	void updateStockSavesProductAfterIncrease() {
		// Arrange
		Long productId = 1L;
		int quantity = 15;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		Product savedProduct = new Product();
		savedProduct.setId(productId);
		savedProduct.setName("Test Product");
		savedProduct.setPrice(BigDecimal.valueOf(100));
		savedProduct.setStock(65);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(product)).thenReturn(savedProduct);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		verify(productRepository, times(1)).save(product);
		assertEquals(savedProduct, result);
	}

	@Test
	@Tag("valid")
	void updateStockSavesProductAfterDecrease() {
		// Arrange
		Long productId = 1L;
		int quantity = -10;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		Product savedProduct = new Product();
		savedProduct.setId(productId);
		savedProduct.setName("Test Product");
		savedProduct.setPrice(BigDecimal.valueOf(100));
		savedProduct.setStock(40);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(product)).thenReturn(savedProduct);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		verify(productRepository, times(1)).save(product);
		assertEquals(savedProduct, result);
	}

	@Test
	@Tag("boundary")
	void updateStockWithQuantityOfOneIncreasesStock() {
		// Arrange
		Long productId = 1L;
		int quantity = 1;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(product).increaseStock(1);
		verify(productRepository).save(product);
	}

	@Test
	@Tag("boundary")
	void updateStockWithQuantityOfNegativeOneDecreasesStock() {
		// Arrange
		Long productId = 1L;
		int quantity = -1;
		Product product = spy(new Product());
		product.setId(productId);
		product.setName("Test Product");
		product.setPrice(BigDecimal.valueOf(100));
		product.setStock(50);
		when(productRepository.findById(productId)).thenReturn(Optional.of(product));
		when(productRepository.save(any(Product.class))).thenReturn(product);
		// Act
		Product result = productService.updateStock(productId, quantity);
		// Assert
		assertNotNull(result);
		verify(product).decreaseStock(1);
		verify(productRepository).save(product);
	}

}