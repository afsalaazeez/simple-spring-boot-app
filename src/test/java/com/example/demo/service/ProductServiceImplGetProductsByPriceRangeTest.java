
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=getProductsByPriceRange_ad85074270
ROOST_METHOD_SIG_HASH=getProductsByPriceRange_db5f2a6903

Scenario 1: Get Products By Price Range With Valid Min And Max Prices

Details:
  TestName: getProductsByPriceRangeWithValidMinAndMaxPrices
  Description: Verify that the method returns products within the specified price range when both minPrice and maxPrice are valid non-null values.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl with it. Configure the mock to return a list of products when findByPriceRange is called with specific min and max prices.
  Act: Invoke getProductsByPriceRange with minPrice = 10.00 and maxPrice = 100.00.
  Assert: Verify that the returned list matches the expected products and that findByPriceRange was called with the correct parameters.

Validation:
  The assertion verifies that when valid price boundaries are provided, the repository method is called with those exact values and the correct products are returned. This is the primary use case for filtering products by price range in e-commerce applications.

---

Scenario 2: Get Products By Price Range With Null Min Price

Details:
  TestName: getProductsByPriceRangeWithNullMinPrice
  Description: Verify that when minPrice is null, it defaults to BigDecimal.ZERO and the method correctly queries the repository.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return a list of products when findByPriceRange is called with BigDecimal.ZERO and a specified maxPrice.
  Act: Invoke getProductsByPriceRange with minPrice = null and maxPrice = 50.00.
  Assert: Verify that findByPriceRange was called with BigDecimal.ZERO as the first parameter and 50.00 as the second parameter.

Validation:
  The assertion confirms that null minPrice is properly handled by defaulting to zero, ensuring users can search for products from the lowest possible price. This provides flexibility in the API usage.

---

Scenario 3: Get Products By Price Range With Null Max Price

Details:
  TestName: getProductsByPriceRangeWithNullMaxPrice
  Description: Verify that when maxPrice is null, it defaults to 999999.99 and the method correctly queries the repository.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return a list of products when findByPriceRange is called with a specified minPrice and BigDecimal("999999.99").
  Act: Invoke getProductsByPriceRange with minPrice = 25.00 and maxPrice = null.
  Assert: Verify that findByPriceRange was called with 25.00 as the first parameter and 999999.99 as the second parameter.

Validation:
  The assertion confirms that null maxPrice is properly handled by defaulting to a high value, allowing users to search for products without an upper price limit. This supports open-ended price range queries.

---

Scenario 4: Get Products By Price Range With Both Null Prices

Details:
  TestName: getProductsByPriceRangeWithBothNullPrices
  Description: Verify that when both minPrice and maxPrice are null, they default to BigDecimal.ZERO and 999999.99 respectively.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return all products when findByPriceRange is called with default values.
  Act: Invoke getProductsByPriceRange with minPrice = null and maxPrice = null.
  Assert: Verify that findByPriceRange was called with BigDecimal.ZERO and BigDecimal("999999.99").

Validation:
  The assertion confirms that when no price constraints are provided, the method effectively returns all products within the maximum possible range. This handles the edge case of completely open queries.

---

Scenario 5: Get Products By Price Range With Min Price Greater Than Max Price

Details:
  TestName: getProductsByPriceRangeWithMinPriceGreaterThanMaxPrice
  Description: Verify that an IllegalArgumentException is thrown when minPrice is greater than maxPrice.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl.
  Act: Invoke getProductsByPriceRange with minPrice = 100.00 and maxPrice = 50.00.
  Assert: Verify that an IllegalArgumentException is thrown with the message "Min price cannot be greater than max price".

Validation:
  The assertion confirms that invalid price range inputs are properly validated and rejected. This prevents illogical queries and provides clear feedback to the caller about the error.

---

Scenario 6: Get Products By Price Range With Equal Min And Max Prices

Details:
  TestName: getProductsByPriceRangeWithEqualMinAndMaxPrices
  Description: Verify that the method works correctly when minPrice equals maxPrice, returning products at that exact price.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return products with the exact price when findByPriceRange is called with equal min and max values.
  Act: Invoke getProductsByPriceRange with minPrice = 50.00 and maxPrice = 50.00.
  Assert: Verify that findByPriceRange was called with both parameters as 50.00 and the correct products are returned.

Validation:
  The assertion confirms that the boundary condition where min equals max is handled correctly, allowing users to search for products at a specific price point.

---

Scenario 7: Get Products By Price Range Returns Empty List

Details:
  TestName: getProductsByPriceRangeReturnsEmptyList
  Description: Verify that the method returns an empty list when no products exist within the specified price range.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return an empty list when findByPriceRange is called.
  Act: Invoke getProductsByPriceRange with minPrice = 1000.00 and maxPrice = 2000.00.
  Assert: Verify that the returned list is empty and not null.

Validation:
  The assertion confirms that the method gracefully handles cases where no products match the criteria, returning an empty list rather than null. This ensures consistent API behavior.

---

Scenario 8: Get Products By Price Range With Zero Min Price

Details:
  TestName: getProductsByPriceRangeWithZeroMinPrice
  Description: Verify that the method correctly handles BigDecimal.ZERO as an explicit minPrice value.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return products when findByPriceRange is called with BigDecimal.ZERO.
  Act: Invoke getProductsByPriceRange with minPrice = BigDecimal.ZERO and maxPrice = 100.00.
  Assert: Verify that findByPriceRange was called with BigDecimal.ZERO and 100.00.

Validation:
  The assertion confirms that explicitly passing zero as minPrice works the same as passing null, ensuring consistent behavior for free or zero-priced products.

---

Scenario 9: Get Products By Price Range With Very Large Max Price

Details:
  TestName: getProductsByPriceRangeWithVeryLargeMaxPrice
  Description: Verify that the method handles very large maxPrice values correctly without overflow or precision issues.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return products when findByPriceRange is called with a large maxPrice.
  Act: Invoke getProductsByPriceRange with minPrice = 0.00 and maxPrice = 999999.99.
  Assert: Verify that findByPriceRange was called with the correct large value and products are returned.

Validation:
  The assertion confirms that the method handles the maximum default price value correctly, ensuring no precision loss with BigDecimal operations.

---

Scenario 10: Get Products By Price Range With Decimal Precision

Details:
  TestName: getProductsByPriceRangeWithDecimalPrecision
  Description: Verify that the method correctly handles prices with decimal precision (cents).

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return products when findByPriceRange is called with precise decimal values.
  Act: Invoke getProductsByPriceRange with minPrice = 10.99 and maxPrice = 99.99.
  Assert: Verify that findByPriceRange was called with the exact decimal values 10.99 and 99.99.

Validation:
  The assertion confirms that BigDecimal precision is maintained throughout the method, which is critical for accurate financial calculations in e-commerce applications.

---

Scenario 11: Get Products By Price Range With Negative Min Price After Null Default

Details:
  TestName: getProductsByPriceRangeMinPriceDefaultsToZeroNotNegative
  Description: Verify that when minPrice is null, it defaults to BigDecimal.ZERO (not a negative value), ensuring valid price range queries.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to capture the arguments passed to findByPriceRange.
  Act: Invoke getProductsByPriceRange with minPrice = null and maxPrice = 100.00.
  Assert: Verify that the minPrice passed to the repository is exactly BigDecimal.ZERO and not negative.

Validation:
  The assertion confirms that the default minimum price is zero, which is the logical lower bound for product prices, preventing negative price queries.

---

Scenario 12: Get Products By Price Range Repository Returns Multiple Products

Details:
  TestName: getProductsByPriceRangeReturnsMultipleProducts
  Description: Verify that the method correctly returns multiple products when the repository finds several matching the price range.

Execution:
  Arrange: Create a mock ProductRepository and set up the ProductServiceImpl. Configure the mock to return a list containing multiple Product objects when findByPriceRange is called.
  Act: Invoke getProductsByPriceRange with minPrice = 10.00 and maxPrice = 500.00.
  Assert: Verify that the returned list contains all expected products and the list size matches the mock configuration.

Validation:
  The assertion confirms that the method properly passes through all products returned by the repository without filtering or modifying them, maintaining data integrity.

*/

// ********RoostGPT********

package com.example.demo.service;

import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Service;
import java.util.Optional;

@ExtendWith(MockitoExtension.class)
class ProductServiceImplGetProductsByPriceRangeTest {

	@Mock
	private ProductRepository productRepository;

	private ProductServiceImpl productService;

	@BeforeEach
	void setUp() {
		productService = new ProductServiceImpl(productRepository);
	}

	@Test
	@Tag("valid")
	void getProductsByPriceRangeWithValidMinAndMaxPrices() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("10.00");
		BigDecimal maxPrice = new BigDecimal("100.00");

		Product product1 = new Product();
		product1.setName("Product 1");
		product1.setPrice(new BigDecimal("25.00"));

		Product product2 = new Product();
		product2.setName("Product 2");
		product2.setPrice(new BigDecimal("75.00"));

		List<Product> expectedProducts = Arrays.asList(product1, product2);
		when(productRepository.findByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(2, result.size());
		assertEquals(expectedProducts, result);
		verify(productRepository).findByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithNullMinPrice() {
		// Arrange
		BigDecimal maxPrice = new BigDecimal("50.00");

		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(new BigDecimal("30.00"));

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(BigDecimal.ZERO, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(null, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(BigDecimal.ZERO, maxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithNullMaxPrice() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("25.00");
		BigDecimal expectedMaxPrice = new BigDecimal("999999.99");

		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(new BigDecimal("500.00"));

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(minPrice, expectedMaxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, null);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(minPrice, expectedMaxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithBothNullPrices() {
		// Arrange
		BigDecimal expectedMinPrice = BigDecimal.ZERO;
		BigDecimal expectedMaxPrice = new BigDecimal("999999.99");

		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(new BigDecimal("100.00"));

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(expectedMinPrice, expectedMaxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(null, null);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(expectedMinPrice, expectedMaxPrice);
	}

	@Test
	@Tag("invalid")
	void getProductsByPriceRangeWithMinPriceGreaterThanMaxPrice() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("100.00");
		BigDecimal maxPrice = new BigDecimal("50.00");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.getProductsByPriceRange(minPrice, maxPrice));

		assertEquals("Min price cannot be greater than max price", exception.getMessage());
		verify(productRepository, never()).findByPriceRange(any(), any());
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithEqualMinAndMaxPrices() {
		// Arrange
		BigDecimal price = new BigDecimal("50.00");

		Product product = new Product();
		product.setName("Exact Price Product");
		product.setPrice(price);

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(price, price)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(price, price);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(price, price);
	}

	@Test
	@Tag("valid")
	void getProductsByPriceRangeReturnsEmptyList() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("1000.00");
		BigDecimal maxPrice = new BigDecimal("2000.00");

		when(productRepository.findByPriceRange(minPrice, maxPrice)).thenReturn(Collections.emptyList());
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertTrue(result.isEmpty());
		verify(productRepository).findByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithZeroMinPrice() {
		// Arrange
		BigDecimal minPrice = BigDecimal.ZERO;
		BigDecimal maxPrice = new BigDecimal("100.00");

		Product product = new Product();
		product.setName("Free Product");
		product.setPrice(BigDecimal.ZERO);

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(BigDecimal.ZERO, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(BigDecimal.ZERO, maxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeWithVeryLargeMaxPrice() {
		// Arrange
		BigDecimal minPrice = BigDecimal.ZERO;
		BigDecimal maxPrice = new BigDecimal("999999.99");

		Product product = new Product();
		product.setName("Expensive Product");
		product.setPrice(new BigDecimal("999999.00"));

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("valid")
	void getProductsByPriceRangeWithDecimalPrecision() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("10.99");
		BigDecimal maxPrice = new BigDecimal("99.99");

		Product product = new Product();
		product.setName("Precise Price Product");
		product.setPrice(new BigDecimal("49.99"));

		List<Product> expectedProducts = Collections.singletonList(product);
		when(productRepository.findByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(1, result.size());
		verify(productRepository).findByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("boundary")
	void getProductsByPriceRangeMinPriceDefaultsToZeroNotNegative() {
		// Arrange
		BigDecimal maxPrice = new BigDecimal("100.00");
		ArgumentCaptor<BigDecimal> minPriceCaptor = ArgumentCaptor.forClass(BigDecimal.class);
		ArgumentCaptor<BigDecimal> maxPriceCaptor = ArgumentCaptor.forClass(BigDecimal.class);

		when(productRepository.findByPriceRange(any(BigDecimal.class), any(BigDecimal.class)))
			.thenReturn(Collections.emptyList());
		// Act
		productService.getProductsByPriceRange(null, maxPrice);
		// Assert
		verify(productRepository).findByPriceRange(minPriceCaptor.capture(), maxPriceCaptor.capture());
		assertEquals(0, minPriceCaptor.getValue().compareTo(BigDecimal.ZERO));
		assertTrue(minPriceCaptor.getValue().compareTo(BigDecimal.ZERO) >= 0);
	}

	@Test
	@Tag("valid")
	void getProductsByPriceRangeReturnsMultipleProducts() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("10.00");
		BigDecimal maxPrice = new BigDecimal("500.00");

		Product product1 = new Product();
		product1.setName("Product 1");
		product1.setPrice(new BigDecimal("50.00"));

		Product product2 = new Product();
		product2.setName("Product 2");
		product2.setPrice(new BigDecimal("150.00"));

		Product product3 = new Product();
		product3.setName("Product 3");
		product3.setPrice(new BigDecimal("300.00"));

		Product product4 = new Product();
		product4.setName("Product 4");
		product4.setPrice(new BigDecimal("450.00"));

		List<Product> expectedProducts = Arrays.asList(product1, product2, product3, product4);
		when(productRepository.findByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		List<Product> result = productService.getProductsByPriceRange(minPrice, maxPrice);
		// Assert
		assertNotNull(result);
		assertEquals(4, result.size());
		assertEquals(expectedProducts, result);
		assertTrue(result.contains(product1));
		assertTrue(result.contains(product2));
		assertTrue(result.contains(product3));
		assertTrue(result.contains(product4));
		verify(productRepository).findByPriceRange(minPrice, maxPrice);
	}

}