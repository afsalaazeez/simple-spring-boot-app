
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=updateProduct_b2c801c6ee
ROOST_METHOD_SIG_HASH=updateProduct_a8bba97f84

Scenario 1: Successfully Update Product When Product Exists With All Valid Fields

Details:
  TestName: updateProductWithAllValidFields
  Description: Verify that when a product exists in the repository and all provided fields (name, description, price, stock) are valid, the product is updated successfully and saved.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, name="Old Name", description="Old Description", price=BigDecimal.TEN, stock=10
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with name="New Name", description="New Description", price=BigDecimal.valueOf(20), stock=20
    - Configure save() to return the updated product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the returned product has the new name "New Name"
    - Verify the returned product has the new description "New Description"
    - Verify the returned product has the new price BigDecimal.valueOf(20)
    - Verify the returned product has the new stock 20
    - Verify productRepository.save() was called once

Validation:
  This test verifies the core functionality of updating all fields of an existing product. It ensures that when valid data is provided, all fields are properly updated and persisted to the repository.

---

Scenario 2: Throw IllegalArgumentException When Product Not Found

Details:
  TestName: updateProductThrowsExceptionWhenProductNotFound
  Description: Verify that when attempting to update a product with an id that does not exist in the repository, an IllegalArgumentException is thrown with the appropriate message.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Configure findById(999L) to return Optional.empty()
    - Create an update Product with valid fields
  Act:
    - Call updateProduct(999L, updateProduct)
  Assert:
    - Verify IllegalArgumentException is thrown
    - Verify exception message contains "Product not found with id: 999"

Validation:
  This test ensures proper error handling when attempting to update a non-existent product. It validates that the system correctly identifies missing products and provides meaningful error messages to the caller.

---

Scenario 3: Update Only Name When Only Name Is Provided

Details:
  TestName: updateProductUpdatesOnlyNameWhenOnlyNameProvided
  Description: Verify that when only the name field is provided in the update product (other fields are null), only the name is updated while other fields remain unchanged.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, name="Old Name", description="Old Description", price=BigDecimal.TEN, stock=10
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with only name="New Name" set, other fields null
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's name was set to "New Name"
    - Verify the existing product's description remains "Old Description"
    - Verify the existing product's price remains BigDecimal.TEN
    - Verify the existing product's stock remains 10

Validation:
  This test verifies partial update functionality, ensuring that only provided fields are updated while null fields are ignored. This is important for supporting PATCH-like update operations.

---

Scenario 4: Do Not Update Name When Name Is Empty String

Details:
  TestName: updateProductDoesNotUpdateNameWhenNameIsEmpty
  Description: Verify that when the provided name is an empty string, the existing product's name is not updated.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, name="Original Name"
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with name="" (empty string)
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's name remains "Original Name"

Validation:
  This test ensures that empty strings are treated as invalid input for the name field, preventing accidental clearing of product names with whitespace-only values.

---

Scenario 5: Do Not Update Name When Name Is Whitespace Only

Details:
  TestName: updateProductDoesNotUpdateNameWhenNameIsWhitespaceOnly
  Description: Verify that when the provided name contains only whitespace characters, the existing product's name is not updated.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, name="Original Name"
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with name="   " (whitespace only)
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's name remains "Original Name"

Validation:
  This test validates the trim() check in the name validation logic, ensuring that whitespace-only names are rejected as invalid input.

---

Scenario 6: Update Description To Empty String

Details:
  TestName: updateProductUpdatesDescriptionToEmptyString
  Description: Verify that when the provided description is an empty string, the existing product's description is updated to the empty string (unlike name, empty description is allowed).

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, description="Old Description"
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with description="" (empty string)
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's description was set to ""

Validation:
  This test verifies that description field allows empty strings, which is different from the name field behavior. This is important for allowing users to clear product descriptions.

---

Scenario 7: Throw IllegalArgumentException When Price Is Negative

Details:
  TestName: updateProductThrowsExceptionWhenPriceIsNegative
  Description: Verify that when attempting to update a product with a negative price, an IllegalArgumentException is thrown.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, price=BigDecimal.TEN
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with price=BigDecimal.valueOf(-5)
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify IllegalArgumentException is thrown
    - Verify exception message is "Product price must be a positive value"

Validation:
  This test ensures business rule enforcement that product prices cannot be negative. This prevents data integrity issues and invalid pricing in the system.

---

Scenario 8: Update Price To Zero Successfully

Details:
  TestName: updateProductUpdatesPriceToZeroSuccessfully
  Description: Verify that when the provided price is exactly zero, the product is updated successfully (zero is not negative).

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, price=BigDecimal.TEN
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with price=BigDecimal.ZERO
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's price was set to BigDecimal.ZERO
    - Verify no exception is thrown

Validation:
  This test verifies the boundary condition where price equals zero. The comparison uses compareTo(BigDecimal.ZERO) < 0, so zero should be accepted as a valid price.

---

Scenario 9: Throw IllegalArgumentException When Stock Is Negative

Details:
  TestName: updateProductThrowsExceptionWhenStockIsNegative
  Description: Verify that when attempting to update a product with a negative stock value, an IllegalArgumentException is thrown.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, stock=10
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with stock=-1
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify IllegalArgumentException is thrown
    - Verify exception message is "Product stock cannot be negative"

Validation:
  This test ensures business rule enforcement that product stock cannot be negative. Negative stock values would indicate invalid inventory state.

---

Scenario 10: Update Stock To Zero Successfully

Details:
  TestName: updateProductUpdatesStockToZeroSuccessfully
  Description: Verify that when the provided stock is exactly zero, the product is updated successfully (zero stock is valid for out-of-stock products).

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, stock=10
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with stock=0
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's stock was set to 0
    - Verify no exception is thrown

Validation:
  This test verifies the boundary condition where stock equals zero. Zero stock is a valid state representing an out-of-stock product.

---

Scenario 11: Update Product With All Null Fields Does Not Modify Existing Product

Details:
  TestName: updateProductWithAllNullFieldsDoesNotModifyExistingProduct
  Description: Verify that when all fields in the update product are null, the existing product remains unchanged but is still saved.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, name="Original", description="Desc", price=BigDecimal.TEN, stock=5
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with all fields set to null
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's name remains "Original"
    - Verify the existing product's description remains "Desc"
    - Verify the existing product's price remains BigDecimal.TEN
    - Verify the existing product's stock remains 5
    - Verify productRepository.save() was called once

Validation:
  This test ensures that providing an empty update object does not corrupt existing data. The save operation still occurs, which may be important for triggering any update timestamps or audit logs.

---

Scenario 12: Update Product With Null Id Parameter

Details:
  TestName: updateProductWithNullIdParameter
  Description: Verify the behavior when null is passed as the id parameter to the updateProduct method.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Configure findById(null) to return Optional.empty() or throw appropriate exception
    - Create an update Product with valid fields
  Act:
    - Call updateProduct(null, updateProduct)
  Assert:
    - Verify appropriate exception is thrown (either IllegalArgumentException or NullPointerException depending on repository behavior)

Validation:
  This test verifies edge case handling when null id is provided. The behavior depends on how the repository handles null ids, but the test ensures consistent error handling.

---

Scenario 13: Update Product With Large Price Value

Details:
  TestName: updateProductWithLargePriceValue
  Description: Verify that the product can be updated with a very large price value without issues.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, price=BigDecimal.TEN
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with price=new BigDecimal("999999999.99")
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's price was set to the large value
    - Verify no exception is thrown

Validation:
  This test verifies that the system can handle large price values, which is important for high-value products or different currency denominations.

---

Scenario 14: Update Product With Large Stock Value

Details:
  TestName: updateProductWithLargeStockValue
  Description: Verify that the product can be updated with a very large stock value (Integer.MAX_VALUE) without issues.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, stock=10
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with stock=Integer.MAX_VALUE
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's stock was set to Integer.MAX_VALUE
    - Verify no exception is thrown

Validation:
  This test verifies boundary handling for stock values, ensuring the system can handle maximum integer values for inventory quantities.

---

Scenario 15: Verify Repository Save Is Called With Correct Product

Details:
  TestName: updateProductCallsRepositorySaveWithExistingProduct
  Description: Verify that the productRepository.save() method is called with the existing product object (not the input product).

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with new values
    - Configure save() to capture the argument and return it
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify productRepository.save() was called exactly once
    - Verify the argument passed to save() is the existing product instance (not the update product)

Validation:
  This test ensures the correct object is being persisted. The method should modify and save the existing product, not create a new one, to maintain entity identity and relationships.

---

Scenario 16: Update Product Price With Decimal Precision

Details:
  TestName: updateProductPriceWithDecimalPrecision
  Description: Verify that the product price can be updated with precise decimal values and the precision is maintained.

Execution:
  Arrange:
    - Create a mock ProductRepository
    - Create an existing Product with id=1L, price=BigDecimal.TEN
    - Configure findById(1L) to return Optional containing the existing product
    - Create an update Product with price=new BigDecimal("19.99")
    - Configure save() to return the product
  Act:
    - Call updateProduct(1L, updateProduct)
  Assert:
    - Verify the existing product's price was set to exactly new BigDecimal("19.99")

Validation:
  This test ensures that decimal precision is maintained for price values, which is critical for accurate financial calculations and display.

*/

// ********RoostGPT********

package com.example.demo.service;

import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.math.BigDecimal;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Service;
import java.util.List;

@ExtendWith(MockitoExtension.class)
class ProductServiceImplUpdateProductTest {

	@Mock
	private ProductRepository productRepository;

	private ProductServiceImpl productService;

	@BeforeEach
	void setUp() {
		productService = new ProductServiceImpl(productRepository);
	}

	@Test
	@Tag("valid")
	void updateProductWithAllValidFields() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Old Name");
		existingProduct.setDescription("Old Description");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setName("New Name");
		updateProduct.setDescription("New Description");
		updateProduct.setPrice(BigDecimal.valueOf(20));
		updateProduct.setStock(20);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertNotNull(result);
		assertEquals("New Name", result.getName());
		assertEquals("New Description", result.getDescription());
		assertEquals(BigDecimal.valueOf(20), result.getPrice());
		assertEquals(20, result.getStock());
		verify(productRepository, times(1)).save(existingProduct);
	}

	@Test
    @Tag("invalid")
    void updateProductThrowsExceptionWhenProductNotFound() {
        // Arrange
        when(productRepository.findById(999L)).thenReturn(Optional.empty());
        Product updateProduct = new Product();
        updateProduct.setName("New Name");
        // Act & Assert
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
                () -> productService.updateProduct(999L, updateProduct));
        assertTrue(exception.getMessage().contains("Product not found with id: 999"));
    }

	@Test
	@Tag("valid")
	void updateProductUpdatesOnlyNameWhenOnlyNameProvided() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Old Name");
		existingProduct.setDescription("Old Description");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setName("New Name");
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals("New Name", result.getName());
		assertEquals("Old Description", result.getDescription());
		assertEquals(BigDecimal.TEN, result.getPrice());
		assertEquals(10, result.getStock());
	}

	@Test
	@Tag("boundary")
	void updateProductDoesNotUpdateNameWhenNameIsEmpty() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Original Name");
		existingProduct.setDescription("Description");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setName("");
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals("Original Name", result.getName());
	}

	@Test
	@Tag("boundary")
	void updateProductDoesNotUpdateNameWhenNameIsWhitespaceOnly() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Original Name");
		existingProduct.setDescription("Description");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setName("   ");
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals("Original Name", result.getName());
	}

	@Test
	@Tag("valid")
	void updateProductUpdatesDescriptionToEmptyString() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setDescription("Old Description");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setDescription("");
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals("", result.getDescription());
	}

	@Test
	@Tag("invalid")
	void updateProductThrowsExceptionWhenPriceIsNegative() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		Product updateProduct = new Product();
		updateProduct.setPrice(BigDecimal.valueOf(-5));
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.updateProduct(1L, updateProduct));
		assertEquals("Product price must be a positive value", exception.getMessage());
	}

	@Test
	@Tag("boundary")
	void updateProductUpdatesPriceToZeroSuccessfully() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setPrice(BigDecimal.ZERO);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals(0, result.getPrice().compareTo(BigDecimal.ZERO));
	}

	@Test
	@Tag("invalid")
	void updateProductThrowsExceptionWhenStockIsNegative() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		Product updateProduct = new Product();
		updateProduct.setStock(-1);
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> productService.updateProduct(1L, updateProduct));
		assertEquals("Product stock cannot be negative", exception.getMessage());
	}

	@Test
	@Tag("boundary")
	void updateProductUpdatesStockToZeroSuccessfully() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setStock(0);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals(0, result.getStock());
	}

	@Test
	@Tag("valid")
	void updateProductWithAllNullFieldsDoesNotModifyExistingProduct() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Original");
		existingProduct.setDescription("Desc");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(5);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals("Original", result.getName());
		assertEquals("Desc", result.getDescription());
		assertEquals(BigDecimal.TEN, result.getPrice());
		assertEquals(5, result.getStock());
		verify(productRepository, times(1)).save(existingProduct);
	}

	@Test
    @Tag("invalid")
    void updateProductWithNullIdParameter() {
        // Arrange
        when(productRepository.findById(null)).thenReturn(Optional.empty());
        Product updateProduct = new Product();
        updateProduct.setName("New Name");
        // Act & Assert
        assertThrows(IllegalArgumentException.class,
                () -> productService.updateProduct(null, updateProduct));
    }

	@Test
	@Tag("boundary")
	void updateProductWithLargePriceValue() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		BigDecimal largePrice = new BigDecimal("999999999.99");
		Product updateProduct = new Product();
		updateProduct.setPrice(largePrice);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals(0, result.getPrice().compareTo(largePrice));
	}

	@Test
	@Tag("boundary")
	void updateProductWithLargeStockValue() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setStock(Integer.MAX_VALUE);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals(Integer.MAX_VALUE, result.getStock());
	}

	@Test
	@Tag("valid")
	void updateProductCallsRepositorySaveWithExistingProduct() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Original");
		existingProduct.setDescription("Desc");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(5);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		Product updateProduct = new Product();
		updateProduct.setName("New Name");
		ArgumentCaptor<Product> productCaptor = ArgumentCaptor.forClass(Product.class);
		// Act
		productService.updateProduct(1L, updateProduct);
		// Assert
		verify(productRepository, times(1)).save(productCaptor.capture());
		assertSame(existingProduct, productCaptor.getValue());
	}

	@Test
	@Tag("valid")
	void updateProductPriceWithDecimalPrecision() {
		// Arrange
		Product existingProduct = new Product();
		existingProduct.setName("Name");
		existingProduct.setPrice(BigDecimal.TEN);
		existingProduct.setStock(10);
		when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
		when(productRepository.save(any(Product.class))).thenAnswer(invocation -> invocation.getArgument(0));
		BigDecimal precisePrice = new BigDecimal("19.99");
		Product updateProduct = new Product();
		updateProduct.setPrice(precisePrice);
		// Act
		Product result = productService.updateProduct(1L, updateProduct);
		// Assert
		assertEquals(0, result.getPrice().compareTo(precisePrice));
	}

}