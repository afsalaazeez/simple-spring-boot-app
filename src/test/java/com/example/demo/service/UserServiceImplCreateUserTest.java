
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=createUser_72ea09bc7d
ROOST_METHOD_SIG_HASH=createUser_3cb88ba3c4

Scenario 1: Successfully Create User with All Valid Fields

Details:
  TestName: createUserWithAllValidFields
  Description: Verify that a user with valid name, email, and role is successfully created and saved to the repository.

Execution:
  Arrange: Create a User object with valid name, email, and role. Mock the userRepository.findByEmail() to return Optional.empty() and userRepository.save() to return the user.
  Act: Call createUser() with the valid user object.
  Assert: Verify that the returned user matches the input user and that userRepository.save() was called once.

Validation:
  This assertion verifies that when all user fields are valid and the email doesn't exist, the user is properly saved. This is the happy path scenario ensuring basic user creation functionality works correctly.

---

Scenario 2: Successfully Create User with Default Role Assignment

Details:
  TestName: createUserWithNullRoleAssignsDefaultRole
  Description: Verify that when a user is created with a null role, the system automatically assigns the default "USER" role.

Execution:
  Arrange: Create a User object with valid name and email but null role. Mock userRepository.findByEmail() to return Optional.empty() and userRepository.save() to return the user.
  Act: Call createUser() with the user object having null role.
  Assert: Verify that user.setRole("USER") was called and the user is saved successfully.

Validation:
  This assertion confirms the default role assignment logic works correctly. This is important business logic ensuring all users have a role assigned for authorization purposes.

---

Scenario 3: Successfully Create User with Empty Role String

Details:
  TestName: createUserWithEmptyRoleAssignsDefaultRole
  Description: Verify that when a user is created with an empty string role, the system automatically assigns the default "USER" role.

Execution:
  Arrange: Create a User object with valid name and email but empty string ("") as role. Mock userRepository.findByEmail() to return Optional.empty().
  Act: Call createUser() with the user object having empty role.
  Assert: Verify that user.setRole("USER") was called and the user is saved.

Validation:
  This validates that empty string roles are treated the same as null roles, ensuring consistent default role assignment behavior.

---

Scenario 4: Successfully Create User with Whitespace-Only Role

Details:
  TestName: createUserWithWhitespaceRoleAssignsDefaultRole
  Description: Verify that when a user is created with a whitespace-only role, the system automatically assigns the default "USER" role.

Execution:
  Arrange: Create a User object with valid name and email but whitespace-only ("   ") as role. Mock userRepository.findByEmail() to return Optional.empty().
  Act: Call createUser() with the user object having whitespace role.
  Assert: Verify that user.setRole("USER") was called and the user is saved.

Validation:
  This ensures that whitespace-only strings are properly trimmed and treated as empty, triggering default role assignment.

---

Scenario 5: Throw Exception When User Name is Null

Details:
  TestName: createUserWithNullNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with a null name.

Execution:
  Arrange: Create a User object with null name, valid email, and valid role.
  Act: Call createUser() with the user object having null name.
  Assert: Verify that IllegalArgumentException is thrown with message "User name cannot be empty".

Validation:
  This validates the name validation logic, ensuring data integrity by preventing users without names from being created.

---

Scenario 6: Throw Exception When User Name is Empty String

Details:
  TestName: createUserWithEmptyNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with an empty string name.

Execution:
  Arrange: Create a User object with empty string ("") name, valid email, and valid role.
  Act: Call createUser() with the user object having empty name.
  Assert: Verify that IllegalArgumentException is thrown with message "User name cannot be empty".

Validation:
  This ensures empty string names are rejected, maintaining data quality standards for user records.

---

Scenario 7: Throw Exception When User Name is Whitespace Only

Details:
  TestName: createUserWithWhitespaceNameThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with a whitespace-only name.

Execution:
  Arrange: Create a User object with whitespace-only ("   ") name, valid email, and valid role.
  Act: Call createUser() with the user object having whitespace name.
  Assert: Verify that IllegalArgumentException is thrown with message "User name cannot be empty".

Validation:
  This confirms that whitespace-only names are properly trimmed and rejected, preventing invalid user data.

---

Scenario 8: Throw Exception When User Email is Null

Details:
  TestName: createUserWithNullEmailThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with a null email.

Execution:
  Arrange: Create a User object with valid name, null email, and valid role.
  Act: Call createUser() with the user object having null email.
  Assert: Verify that IllegalArgumentException is thrown with message "User email cannot be empty".

Validation:
  This validates email validation logic, ensuring all users have an email address for identification and communication.

---

Scenario 9: Throw Exception When User Email is Empty String

Details:
  TestName: createUserWithEmptyEmailThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with an empty string email.

Execution:
  Arrange: Create a User object with valid name, empty string ("") email, and valid role.
  Act: Call createUser() with the user object having empty email.
  Assert: Verify that IllegalArgumentException is thrown with message "User email cannot be empty".

Validation:
  This ensures empty string emails are rejected, maintaining the requirement for valid email addresses.

---

Scenario 10: Throw Exception When User Email is Whitespace Only

Details:
  TestName: createUserWithWhitespaceEmailThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with a whitespace-only email.

Execution:
  Arrange: Create a User object with valid name, whitespace-only ("   ") email, and valid role.
  Act: Call createUser() with the user object having whitespace email.
  Assert: Verify that IllegalArgumentException is thrown with message "User email cannot be empty".

Validation:
  This confirms that whitespace-only emails are properly trimmed and rejected as invalid.

---

Scenario 11: Throw Exception When Email Already Exists

Details:
  TestName: createUserWithExistingEmailThrowsException
  Description: Verify that an IllegalArgumentException is thrown when attempting to create a user with an email that already exists in the system.

Execution:
  Arrange: Create a User object with valid name, email "existing@test.com", and valid role. Mock userRepository.findByEmail("existing@test.com") to return Optional.of(existingUser).
  Act: Call createUser() with the user object having duplicate email.
  Assert: Verify that IllegalArgumentException is thrown with message "User with email existing@test.com already exists".

Validation:
  This validates the email uniqueness constraint, ensuring no duplicate email addresses exist in the system for user identification purposes.

---

Scenario 12: Verify Repository Save is Called with Correct User

Details:
  TestName: createUserCallsRepositorySaveWithCorrectUser
  Description: Verify that the userRepository.save() method is called exactly once with the correct user object.

Execution:
  Arrange: Create a valid User object. Mock userRepository.findByEmail() to return Optional.empty() and capture the argument passed to save().
  Act: Call createUser() with the valid user object.
  Assert: Verify that userRepository.save() was called exactly once with the expected user object.

Validation:
  This ensures the service properly delegates persistence to the repository layer with the correct data.

---

Scenario 13: Verify Email Check is Performed Before Save

Details:
  TestName: createUserChecksEmailExistenceBeforeSave
  Description: Verify that the email existence check is performed before attempting to save the user.

Execution:
  Arrange: Create a valid User object. Mock userRepository.findByEmail() to return Optional.of(existingUser).
  Act: Call createUser() with the user object.
  Assert: Verify that userRepository.findByEmail() was called and userRepository.save() was never called.

Validation:
  This confirms the validation order is correct, preventing unnecessary save operations when validation fails.

---

Scenario 14: Create User with Valid Name Containing Special Characters

Details:
  TestName: createUserWithSpecialCharactersInName
  Description: Verify that a user with special characters in the name (e.g., "José O'Brien-Smith") is successfully created.

Execution:
  Arrange: Create a User object with name "José O'Brien-Smith", valid email, and valid role. Mock repository methods appropriately.
  Act: Call createUser() with the user object.
  Assert: Verify that the user is saved successfully without any exceptions.

Validation:
  This ensures the system accepts international names and names with special characters, supporting diverse user bases.

---

Scenario 15: Verify Name Validation Occurs Before Email Validation

Details:
  TestName: createUserValidatesNameBeforeEmail
  Description: Verify that name validation is performed before email validation when both are invalid.

Execution:
  Arrange: Create a User object with null name and null email.
  Act: Call createUser() with the user object.
  Assert: Verify that IllegalArgumentException is thrown with message "User name cannot be empty" (not email message).

Validation:
  This confirms the validation order follows the code structure, providing consistent error messages to users.

*/

// ********RoostGPT********

package com.example.demo.service;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Service;
import java.util.List;

@ExtendWith(MockitoExtension.class)
class UserServiceImplCreateUserTest {

	@Mock
	private UserRepository userRepository;

	private UserServiceImpl userService;

	@BeforeEach
	void setUp() {
		userService = new UserServiceImpl(userRepository);
	}

	@Test
	@Tag("valid")
	void createUserWithAllValidFields() {
		// Arrange
		User user = new User();
		user.setName("John Doe");
		user.setEmail("john.doe@test.com");
		user.setRole("ADMIN");
		when(userRepository.findByEmail("john.doe@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenReturn(user);
		// Act
		User result = userService.createUser(user);
		// Assert
		assertNotNull(result);
		assertEquals("John Doe", result.getName());
		assertEquals("john.doe@test.com", result.getEmail());
		assertEquals("ADMIN", result.getRole());
		verify(userRepository, times(1)).save(user);
	}

	@Test
	@Tag("valid")
	void createUserWithNullRoleAssignsDefaultRole() {
		// Arrange
		User user = new User();
		user.setName("Jane Doe");
		user.setEmail("jane.doe@test.com");
		user.setRole(null);
		when(userRepository.findByEmail("jane.doe@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
		// Act
		User result = userService.createUser(user);
		// Assert
		assertNotNull(result);
		assertEquals("USER", result.getRole());
		verify(userRepository, times(1)).save(user);
	}

	@Test
	@Tag("valid")
	void createUserWithEmptyRoleAssignsDefaultRole() {
		// Arrange
		User user = new User();
		user.setName("Jane Doe");
		user.setEmail("jane.doe@test.com");
		user.setRole("");
		when(userRepository.findByEmail("jane.doe@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
		// Act
		User result = userService.createUser(user);
		// Assert
		assertNotNull(result);
		assertEquals("USER", result.getRole());
		verify(userRepository, times(1)).save(user);
	}

	@Test
	@Tag("valid")
	void createUserWithWhitespaceRoleAssignsDefaultRole() {
		// Arrange
		User user = new User();
		user.setName("Jane Doe");
		user.setEmail("jane.doe@test.com");
		user.setRole("   ");
		when(userRepository.findByEmail("jane.doe@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenAnswer(invocation -> invocation.getArgument(0));
		// Act
		User result = userService.createUser(user);
		// Assert
		assertNotNull(result);
		assertEquals("USER", result.getRole());
		verify(userRepository, times(1)).save(user);
	}

	@Test
	@Tag("invalid")
	void createUserWithNullNameThrowsException() {
		// Arrange
		User user = new User();
		user.setName(null);
		user.setEmail("test@test.com");
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User name cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithEmptyNameThrowsException() {
		// Arrange
		User user = new User();
		user.setName("");
		user.setEmail("test@test.com");
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User name cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithWhitespaceNameThrowsException() {
		// Arrange
		User user = new User();
		user.setName("   ");
		user.setEmail("test@test.com");
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User name cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithNullEmailThrowsException() {
		// Arrange
		User user = new User();
		user.setName("John Doe");
		user.setEmail(null);
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User email cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithEmptyEmailThrowsException() {
		// Arrange
		User user = new User();
		user.setName("John Doe");
		user.setEmail("");
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User email cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithWhitespaceEmailThrowsException() {
		// Arrange
		User user = new User();
		user.setName("John Doe");
		user.setEmail("   ");
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User email cannot be empty", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("invalid")
	void createUserWithExistingEmailThrowsException() {
		// Arrange
		User existingUser = new User();
		existingUser.setName("Existing User");
		existingUser.setEmail("existing@test.com");
		existingUser.setRole("USER");
		User newUser = new User();
		newUser.setName("New User");
		newUser.setEmail("existing@test.com");
		newUser.setRole("USER");
		when(userRepository.findByEmail("existing@test.com")).thenReturn(Optional.of(existingUser));
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(newUser));
		assertEquals("User with email existing@test.com already exists", exception.getMessage());
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("integration")
	void createUserCallsRepositorySaveWithCorrectUser() {
		// Arrange
		User user = new User();
		user.setName("John Doe");
		user.setEmail("john.doe@test.com");
		user.setRole("ADMIN");
		ArgumentCaptor<User> userCaptor = ArgumentCaptor.forClass(User.class);
		when(userRepository.findByEmail("john.doe@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenReturn(user);
		// Act
		userService.createUser(user);
		// Assert
		verify(userRepository, times(1)).save(userCaptor.capture());
		User capturedUser = userCaptor.getValue();
		assertEquals("John Doe", capturedUser.getName());
		assertEquals("john.doe@test.com", capturedUser.getEmail());
		assertEquals("ADMIN", capturedUser.getRole());
	}

	@Test
	@Tag("integration")
	void createUserChecksEmailExistenceBeforeSave() {
		// Arrange
		User existingUser = new User();
		existingUser.setName("Existing User");
		existingUser.setEmail("existing@test.com");
		existingUser.setRole("USER");
		User newUser = new User();
		newUser.setName("New User");
		newUser.setEmail("existing@test.com");
		newUser.setRole("USER");
		when(userRepository.findByEmail("existing@test.com")).thenReturn(Optional.of(existingUser));
		// Act & Assert
		assertThrows(IllegalArgumentException.class, () -> userService.createUser(newUser));
		verify(userRepository, times(1)).findByEmail("existing@test.com");
		verify(userRepository, never()).save(any(User.class));
	}

	@Test
	@Tag("valid")
	void createUserWithSpecialCharactersInName() {
		// Arrange
		User user = new User();
		user.setName("José O'Brien-Smith");
		user.setEmail("jose.obrien@test.com");
		user.setRole("USER");
		when(userRepository.findByEmail("jose.obrien@test.com")).thenReturn(Optional.empty());
		when(userRepository.save(any(User.class))).thenReturn(user);
		// Act
		User result = userService.createUser(user);
		// Assert
		assertNotNull(result);
		assertEquals("José O'Brien-Smith", result.getName());
		verify(userRepository, times(1)).save(user);
	}

	@Test
	@Tag("boundary")
	void createUserValidatesNameBeforeEmail() {
		// Arrange
		User user = new User();
		user.setName(null);
		user.setEmail(null);
		user.setRole("USER");
		// Act & Assert
		IllegalArgumentException exception = assertThrows(IllegalArgumentException.class,
				() -> userService.createUser(user));
		assertEquals("User name cannot be empty", exception.getMessage());
		verify(userRepository, never()).findByEmail(anyString());
		verify(userRepository, never()).save(any(User.class));
	}

}