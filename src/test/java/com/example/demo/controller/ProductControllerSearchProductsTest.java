
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=searchProducts_97c5f709f4
ROOST_METHOD_SIG_HASH=searchProducts_1aee40bcf8

Scenario 1: Search Products by Name Only

Details:
  TestName: searchProductsByNameWhenNoPrice
  Description: Verify that when only the name parameter is provided (minPrice and maxPrice are null), the method searches products by name using the productService.searchProductsByName method.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when searchProductsByName is called with the given name
  Act:
    - Call searchProducts with name="TestProduct", minPrice=null, maxPrice=null
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains the expected list of products
    - Verify productService.searchProductsByName was called with "TestProduct"

Validation:
  This test verifies that the method correctly routes to name-based search when no price parameters are provided. This is important for ensuring the search functionality works correctly for users searching by product name.

---

Scenario 2: Search Products by Price Range with Both Min and Max Price

Details:
  TestName: searchProductsByPriceRangeWithBothMinAndMax
  Description: Verify that when both minPrice and maxPrice parameters are provided, the method searches products by price range using productService.getProductsByPriceRange.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=BigDecimal.valueOf(10.00), maxPrice=BigDecimal.valueOf(100.00)
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains the expected list of products
    - Verify productService.getProductsByPriceRange was called with the correct min and max values

Validation:
  This test ensures that price range filtering takes precedence over name search when price parameters are provided. This is critical for users who want to filter products within a specific budget.

---

Scenario 3: Search Products with Only Min Price Provided

Details:
  TestName: searchProductsWithOnlyMinPrice
  Description: Verify that when only minPrice is provided (maxPrice is null), the method still uses price range search with getProductsByPriceRange.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=BigDecimal.valueOf(50.00), maxPrice=null
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains the expected list of products
    - Verify productService.getProductsByPriceRange was called with minPrice and null maxPrice

Validation:
  This test verifies that providing only a minimum price triggers the price range search. This allows users to find products above a certain price threshold.

---

Scenario 4: Search Products with Only Max Price Provided

Details:
  TestName: searchProductsWithOnlyMaxPrice
  Description: Verify that when only maxPrice is provided (minPrice is null), the method uses price range search with getProductsByPriceRange.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=null, maxPrice=BigDecimal.valueOf(200.00)
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains the expected list of products
    - Verify productService.getProductsByPriceRange was called with null minPrice and the provided maxPrice

Validation:
  This test ensures that providing only a maximum price triggers the price range search. This is useful for users looking for products under a certain price.

---

Scenario 5: Search Products with All Parameters Null

Details:
  TestName: searchProductsWithAllParametersNull
  Description: Verify that when all parameters (name, minPrice, maxPrice) are null, the method defaults to searching by name with a null value.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when searchProductsByName is called with null
  Act:
    - Call searchProducts with name=null, minPrice=null, maxPrice=null
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains the expected list of products
    - Verify productService.searchProductsByName was called with null

Validation:
  This test verifies the default behavior when no search criteria are provided. The service layer should handle the null name appropriately, potentially returning all products or an empty list.

---

Scenario 6: Search Products with Name and Price Range Both Provided

Details:
  TestName: searchProductsWithNameAndPriceRangePrioritizesPrice
  Description: Verify that when both name and price parameters are provided, the price range search takes precedence over name search.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name="TestProduct", minPrice=BigDecimal.valueOf(10.00), maxPrice=BigDecimal.valueOf(100.00)
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.getProductsByPriceRange was called
    - Verify productService.searchProductsByName was NOT called

Validation:
  This test confirms the method's priority logic: price range filtering takes precedence when price parameters are present, even if a name is also provided. This is important for understanding the API's behavior.

---

Scenario 7: Search Products Returns Empty List

Details:
  TestName: searchProductsReturnsEmptyListWhenNoMatches
  Description: Verify that the method returns an empty list with HTTP 200 OK when no products match the search criteria.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Configure the mock to return an empty list when searchProductsByName is called
  Act:
    - Call searchProducts with name="NonExistentProduct", minPrice=null, maxPrice=null
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify the response body contains an empty list

Validation:
  This test ensures that the method handles the case of no matching products gracefully by returning an empty list rather than an error. This is standard REST API behavior for search operations.

---

Scenario 8: Search Products with Zero Price Values

Details:
  TestName: searchProductsWithZeroPriceValues
  Description: Verify that the method correctly handles zero values for minPrice and maxPrice.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=BigDecimal.ZERO, maxPrice=BigDecimal.ZERO
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.getProductsByPriceRange was called with BigDecimal.ZERO for both parameters

Validation:
  This test verifies that zero is treated as a valid price value (not null) and triggers the price range search. This edge case is important for products that might be free or have zero cost.

---

Scenario 9: Search Products with Negative Price Values

Details:
  TestName: searchProductsWithNegativePriceValues
  Description: Verify the method's behavior when negative price values are provided as parameters.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=BigDecimal.valueOf(-10.00), maxPrice=BigDecimal.valueOf(100.00)
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.getProductsByPriceRange was called with the negative minPrice value

Validation:
  This test checks how the controller handles invalid input (negative prices). The controller passes the values to the service layer, which should handle validation. This tests the separation of concerns.

---

Scenario 10: Search Products with Empty String Name

Details:
  TestName: searchProductsWithEmptyStringName
  Description: Verify that the method correctly handles an empty string for the name parameter.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when searchProductsByName is called with empty string
  Act:
    - Call searchProducts with name="", minPrice=null, maxPrice=null
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.searchProductsByName was called with an empty string

Validation:
  This test ensures that an empty string is treated differently from null and is passed to the service layer. The service layer should determine how to handle empty string searches.

---

Scenario 11: Search Products with Large Price Values

Details:
  TestName: searchProductsWithLargePriceValues
  Description: Verify that the method correctly handles very large BigDecimal price values.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=new BigDecimal("999999999.99"), maxPrice=new BigDecimal("9999999999.99")
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.getProductsByPriceRange was called with the large price values

Validation:
  This test verifies that the method can handle large price values without overflow or precision issues. This is important for high-value products or currencies with large denominations.

---

Scenario 12: Search Products with Decimal Precision in Prices

Details:
  TestName: searchProductsWithDecimalPrecisionPrices
  Description: Verify that the method correctly handles BigDecimal values with multiple decimal places.

Execution:
  Arrange:
    - Create a mock ProductService instance
    - Create a ProductController with the mocked ProductService
    - Prepare a list of Product objects to be returned by the mock
    - Configure the mock to return the product list when getProductsByPriceRange is called
  Act:
    - Call searchProducts with name=null, minPrice=new BigDecimal("10.999"), maxPrice=new BigDecimal("100.001")
  Assert:
    - Verify the response status is HTTP 200 OK
    - Verify productService.getProductsByPriceRange was called with the precise decimal values

Validation:
  This test ensures that decimal precision is maintained when passing price values to the service layer. This is crucial for accurate price filtering in financial applications.

*/

// ********RoostGPT********

package com.example.demo.controller;

import com.example.demo.model.Product;
import com.example.demo.service.ProductService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.web.bind.annotation.*;
import java.util.HashMap;
import java.util.Map;

@ExtendWith(MockitoExtension.class)
class ProductControllerSearchProductsTest {

	@Mock
	private ProductService productService;

	private ProductController productController;

	@BeforeEach
	void setUp() {
		productController = new ProductController(productService);
	}

	@Test
	@Tag("valid")
	void searchProductsByNameWhenNoPrice() {
		// Arrange
		String searchName = "TestProduct";
		List<Product> expectedProducts = Arrays.asList(new Product(), new Product());
		when(productService.searchProductsByName(searchName)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(searchName, null, null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).searchProductsByName(searchName);
		verify(productService, never()).getProductsByPriceRange(any(), any());
	}

	@Test
	@Tag("valid")
	void searchProductsByPriceRangeWithBothMinAndMax() {
		// Arrange
		BigDecimal minPrice = BigDecimal.valueOf(10.00);
		BigDecimal maxPrice = BigDecimal.valueOf(100.00);
		List<Product> expectedProducts = Arrays.asList(new Product(), new Product());
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, maxPrice);
		verify(productService, never()).searchProductsByName(any());
	}

	@Test
	@Tag("valid")
	void searchProductsWithOnlyMinPrice() {
		// Arrange
		BigDecimal minPrice = BigDecimal.valueOf(50.00);
		List<Product> expectedProducts = Arrays.asList(new Product());
		when(productService.getProductsByPriceRange(minPrice, null)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, null);
		verify(productService, never()).searchProductsByName(any());
	}

	@Test
	@Tag("valid")
	void searchProductsWithOnlyMaxPrice() {
		// Arrange
		BigDecimal maxPrice = BigDecimal.valueOf(200.00);
		List<Product> expectedProducts = Arrays.asList(new Product(), new Product(), new Product());
		when(productService.getProductsByPriceRange(null, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, null, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).getProductsByPriceRange(null, maxPrice);
		verify(productService, never()).searchProductsByName(any());
	}

	@Test
	@Tag("boundary")
	void searchProductsWithAllParametersNull() {
		// Arrange
		List<Product> expectedProducts = new ArrayList<>();
		when(productService.searchProductsByName(null)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, null, null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).searchProductsByName(null);
		verify(productService, never()).getProductsByPriceRange(any(), any());
	}

	@Test
	@Tag("valid")
	void searchProductsWithNameAndPriceRangePrioritizesPrice() {
		// Arrange
		String searchName = "TestProduct";
		BigDecimal minPrice = BigDecimal.valueOf(10.00);
		BigDecimal maxPrice = BigDecimal.valueOf(100.00);
		List<Product> expectedProducts = Arrays.asList(new Product());
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(searchName, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, maxPrice);
		verify(productService, never()).searchProductsByName(any());
	}

	@Test
	@Tag("valid")
	void searchProductsReturnsEmptyListWhenNoMatches() {
		// Arrange
		String searchName = "NonExistentProduct";
		List<Product> emptyList = Collections.emptyList();
		when(productService.searchProductsByName(searchName)).thenReturn(emptyList);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(searchName, null, null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody().isEmpty());
		verify(productService).searchProductsByName(searchName);
	}

	@Test
	@Tag("boundary")
	void searchProductsWithZeroPriceValues() {
		// Arrange
		BigDecimal minPrice = BigDecimal.ZERO;
		BigDecimal maxPrice = BigDecimal.ZERO;
		List<Product> expectedProducts = new ArrayList<>();
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		verify(productService).getProductsByPriceRange(BigDecimal.ZERO, BigDecimal.ZERO);
		verify(productService, never()).searchProductsByName(any());
	}

	@Test
	@Tag("invalid")
	void searchProductsWithNegativePriceValues() {
		// Arrange
		BigDecimal minPrice = BigDecimal.valueOf(-10.00);
		BigDecimal maxPrice = BigDecimal.valueOf(100.00);
		List<Product> expectedProducts = new ArrayList<>();
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("boundary")
	void searchProductsWithEmptyStringName() {
		// Arrange
		String emptyName = "";
		List<Product> expectedProducts = Arrays.asList(new Product());
		when(productService.searchProductsByName(emptyName)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(emptyName, null, null);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).searchProductsByName(emptyName);
		verify(productService, never()).getProductsByPriceRange(any(), any());
	}

	@Test
	@Tag("boundary")
	void searchProductsWithLargePriceValues() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("999999999.99");
		BigDecimal maxPrice = new BigDecimal("9999999999.99");
		List<Product> expectedProducts = new ArrayList<>();
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, maxPrice);
	}

	@Test
	@Tag("boundary")
	void searchProductsWithDecimalPrecisionPrices() {
		// Arrange
		BigDecimal minPrice = new BigDecimal("10.999");
		BigDecimal maxPrice = new BigDecimal("100.001");
		List<Product> expectedProducts = Arrays.asList(new Product());
		when(productService.getProductsByPriceRange(minPrice, maxPrice)).thenReturn(expectedProducts);
		// Act
		ResponseEntity<List<Product>> response = productController.searchProducts(null, minPrice, maxPrice);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertEquals(expectedProducts, response.getBody());
		verify(productService).getProductsByPriceRange(minPrice, maxPrice);
	}

}