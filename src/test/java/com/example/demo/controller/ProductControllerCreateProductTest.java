
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=createProduct_347062ec88
ROOST_METHOD_SIG_HASH=createProduct_9b5a031bb4

Scenario 1: Successfully Create a Valid Product

Details:
  TestName: createProductWithValidData
  Description: Verify that when a valid Product object is passed to the createProduct method, it successfully creates the product and returns a ResponseEntity with HTTP status 201 (CREATED) containing the created product in the body.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a valid Product object with all required fields
    - Configure the mock to return the created product when createProduct is called
  Act:
    - Invoke createProduct method with the valid Product object
  Assert:
    - Verify the response status is HttpStatus.CREATED (201)
    - Verify the response body contains the created Product object
    - Verify productService.createProduct was called exactly once with the provided product

Validation:
  This assertion verifies that the controller correctly delegates product creation to the service layer and returns the appropriate HTTP status code for resource creation. This is essential for RESTful API compliance where 201 CREATED indicates successful resource creation.

---

Scenario 2: Create Product with Null Product Object

Details:
  TestName: createProductWithNullProduct
  Description: Verify the behavior when a null Product object is passed to the createProduct method. The service layer should throw an IllegalArgumentException, resulting in a BAD_REQUEST response.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Configure the mock to throw IllegalArgumentException when createProduct is called with null
  Act:
    - Invoke createProduct method with null
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body contains an error map with the exception message

Validation:
  This assertion ensures that the controller properly handles null input by catching the IllegalArgumentException and returning a user-friendly error response with appropriate HTTP status code. This validates proper error handling for invalid input.

---

Scenario 3: Create Product with Empty Name

Details:
  TestName: createProductWithEmptyName
  Description: Verify that when a Product with an empty or blank name is passed, the service throws an IllegalArgumentException and the controller returns a BAD_REQUEST response with an error message.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with an empty name
    - Configure the mock to throw IllegalArgumentException with message "Product name cannot be empty"
  Act:
    - Invoke createProduct method with the Product having empty name
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body contains a Map with key "error" and the appropriate message

Validation:
  This test validates that business rule violations (empty product name) are properly communicated to the client through appropriate HTTP status codes and error messages. This ensures data integrity and proper validation feedback.

---

Scenario 4: Create Product with Negative Price

Details:
  TestName: createProductWithNegativePrice
  Description: Verify that when a Product with a negative price is passed, the service throws an IllegalArgumentException and the controller returns a BAD_REQUEST response.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with a negative BigDecimal price
    - Configure the mock to throw IllegalArgumentException with message "Price cannot be negative"
  Act:
    - Invoke createProduct method with the Product having negative price
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body contains the error message about negative price

Validation:
  This assertion verifies that the controller correctly handles business validation errors related to pricing. Negative prices are invalid in most business contexts, and this test ensures proper error handling and client notification.

---

Scenario 5: Create Product with Negative Stock Quantity

Details:
  TestName: createProductWithNegativeStock
  Description: Verify that when a Product with negative stock quantity is passed, the service throws an IllegalArgumentException and the controller returns a BAD_REQUEST response.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with negative stock quantity
    - Configure the mock to throw IllegalArgumentException with message "Stock quantity cannot be negative"
  Act:
    - Invoke createProduct method with the Product having negative stock
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body contains the appropriate error message

Validation:
  This test ensures that inventory-related validation errors are properly handled. Negative stock quantities are logically invalid, and the system should reject such inputs with clear error messaging.

---

Scenario 6: Create Product with Duplicate Name

Details:
  TestName: createProductWithDuplicateName
  Description: Verify that when attempting to create a Product with a name that already exists in the system, the service throws an IllegalArgumentException and the controller returns a BAD_REQUEST response.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with a name that already exists
    - Configure the mock to throw IllegalArgumentException with message "Product with this name already exists"
  Act:
    - Invoke createProduct method with the duplicate-named Product
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body contains the duplicate name error message

Validation:
  This assertion validates that uniqueness constraints are enforced and properly communicated to the client. Preventing duplicate product names maintains data integrity and prevents confusion in the product catalog.

---

Scenario 7: Create Product with Zero Price

Details:
  TestName: createProductWithZeroPrice
  Description: Verify the behavior when a Product with zero price is passed. Depending on business rules, this may be valid (for free products) or invalid.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with BigDecimal.ZERO as price
    - Configure the mock to return the created product (assuming zero price is valid)
  Act:
    - Invoke createProduct method with the zero-priced Product
  Assert:
    - Verify the response status is HttpStatus.CREATED (201)
    - Verify the response body contains the created Product with zero price

Validation:
  This test verifies edge case handling for zero-priced products. Some business models allow free products, and this test ensures the system handles this boundary condition correctly.

---

Scenario 8: Create Product with Very Large Price Value

Details:
  TestName: createProductWithLargePrice
  Description: Verify that the system can handle Products with very large price values without overflow or precision issues.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with a very large BigDecimal price value
    - Configure the mock to return the created product successfully
  Act:
    - Invoke createProduct method with the high-priced Product
  Assert:
    - Verify the response status is HttpStatus.CREATED (201)
    - Verify the response body contains the Product with the correct large price value

Validation:
  This test ensures that the system handles extreme price values correctly, which is important for high-value products or currencies with large denominations. BigDecimal should handle this without precision loss.

---

Scenario 9: Create Product with Special Characters in Name

Details:
  TestName: createProductWithSpecialCharactersInName
  Description: Verify that Products with special characters in their names are handled correctly by the system.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create a Product object with special characters in the name (e.g., "Product™ & Co. #1")
    - Configure the mock to return the created product successfully
  Act:
    - Invoke createProduct method with the special-character-named Product
  Assert:
    - Verify the response status is HttpStatus.CREATED (201)
    - Verify the response body contains the Product with the special characters preserved

Validation:
  This assertion verifies that the system correctly handles and preserves special characters in product names, which is important for international products, trademarked names, and proper data integrity.

---

Scenario 10: Verify Error Response Structure

Details:
  TestName: verifyErrorResponseContainsCorrectStructure
  Description: Verify that when an IllegalArgumentException is thrown, the error response follows the expected structure with an "error" key containing the exception message.

Execution:
  Arrange:
    - Create a mock of ProductService
    - Create a ProductController instance with the mocked ProductService
    - Create an invalid Product object
    - Configure the mock to throw IllegalArgumentException with a specific message "Validation failed"
  Act:
    - Invoke createProduct method with the invalid Product
  Assert:
    - Verify the response status is HttpStatus.BAD_REQUEST (400)
    - Verify the response body is a Map containing exactly one entry
    - Verify the Map has key "error" with value "Validation failed"

Validation:
  This test ensures consistent error response formatting across the API. Standardized error responses make it easier for API consumers to handle errors programmatically and provide better user experience.

*/

// ********RoostGPT********
package com.example.demo.controller;

import com.example.demo.model.Product;
import com.example.demo.service.ProductService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import java.math.BigDecimal;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.springframework.web.bind.annotation.*;
import java.util.HashMap;
import java.util.List;

@ExtendWith(MockitoExtension.class)
class ProductControllerCreateProductTest {

	@Mock
	private ProductService productService;

	private ProductController productController;

	@BeforeEach
	void setUp() {
		productController = new ProductController(productService);
	}

	@Test
	@Tag("valid")
	void createProductWithValidData() {
		// Arrange
		Product product = new Product();
		product.setId(1L);
		product.setName("Test Product");
		product.setPrice(new BigDecimal("29.99"));
		// Note: Product class does not have setQuantity method.
		// If quantity field is needed, add setQuantity(int quantity) method to Product
		// class.
		when(productService.createProduct(any(Product.class))).thenReturn(product);
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.CREATED, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Product);
		Product createdProduct = (Product) response.getBody();
		assertEquals("Test Product", createdProduct.getName());
		assertEquals(new BigDecimal("29.99"), createdProduct.getPrice());
		verify(productService, times(1)).createProduct(product);
	}

	@Test
    @Tag("invalid")
    void createProductWithNullProduct() {
        // Arrange
        when(productService.createProduct(null)).thenThrow(new IllegalArgumentException("Product cannot be null"));
        // Act
        ResponseEntity<?> response = productController.createProduct(null);
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody() instanceof Map);
        @SuppressWarnings("unchecked")
        Map<String, String> errorResponse = (Map<String, String>) response.getBody();
        assertEquals("Product cannot be null", errorResponse.get("error"));
    }

	@Test
	@Tag("invalid")
	void createProductWithEmptyName() {
		// Arrange
		Product product = new Product();
		product.setName("");
		product.setPrice(new BigDecimal("19.99"));
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class)))
			.thenThrow(new IllegalArgumentException("Product name cannot be empty"));
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);
		@SuppressWarnings("unchecked")
		Map<String, String> errorResponse = (Map<String, String>) response.getBody();
		assertEquals("Product name cannot be empty", errorResponse.get("error"));
	}

	@Test
	@Tag("invalid")
	void createProductWithNegativePrice() {
		// Arrange
		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(new BigDecimal("-10.00"));
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class)))
			.thenThrow(new IllegalArgumentException("Price cannot be negative"));
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);
		@SuppressWarnings("unchecked")
		Map<String, String> errorResponse = (Map<String, String>) response.getBody();
		assertEquals("Price cannot be negative", errorResponse.get("error"));
	}

	@Test
	@Tag("invalid")
	void createProductWithNegativeStock() {
		// Arrange
		Product product = new Product();
		product.setName("Test Product");
		product.setPrice(new BigDecimal("25.00"));
		// Note: Product class does not have setQuantity method.
		// To test negative stock, add setQuantity(int quantity) method to Product class.
		when(productService.createProduct(any(Product.class)))
			.thenThrow(new IllegalArgumentException("Stock quantity cannot be negative"));
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);
		@SuppressWarnings("unchecked")
		Map<String, String> errorResponse = (Map<String, String>) response.getBody();
		assertEquals("Stock quantity cannot be negative", errorResponse.get("error"));
	}

	@Test
	@Tag("invalid")
	void createProductWithDuplicateName() {
		// Arrange
		Product product = new Product();
		product.setName("Existing Product");
		product.setPrice(new BigDecimal("15.00"));
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class)))
			.thenThrow(new IllegalArgumentException("Product with this name already exists"));
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);
		@SuppressWarnings("unchecked")
		Map<String, String> errorResponse = (Map<String, String>) response.getBody();
		assertEquals("Product with this name already exists", errorResponse.get("error"));
	}

	@Test
	@Tag("boundary")
	void createProductWithZeroPrice() {
		// Arrange
		Product product = new Product();
		product.setId(2L);
		product.setName("Free Product");
		product.setPrice(BigDecimal.ZERO);
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class))).thenReturn(product);
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.CREATED, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Product);
		Product createdProduct = (Product) response.getBody();
		assertEquals(BigDecimal.ZERO, createdProduct.getPrice());
		verify(productService, times(1)).createProduct(product);
	}

	@Test
	@Tag("boundary")
	void createProductWithLargePrice() {
		// Arrange
		Product product = new Product();
		product.setId(3L);
		product.setName("Luxury Product");
		BigDecimal largePrice = new BigDecimal("999999999999.99");
		product.setPrice(largePrice);
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class))).thenReturn(product);
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.CREATED, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Product);
		Product createdProduct = (Product) response.getBody();
		assertEquals(largePrice, createdProduct.getPrice());
		verify(productService, times(1)).createProduct(product);
	}

	@Test
	@Tag("valid")
	void createProductWithSpecialCharactersInName() {
		// Arrange
		Product product = new Product();
		product.setId(4L);
		product.setName("Product™ & Co. #1");
		product.setPrice(new BigDecimal("49.99"));
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class))).thenReturn(product);
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.CREATED, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Product);
		Product createdProduct = (Product) response.getBody();
		assertEquals("Product™ & Co. #1", createdProduct.getName());
		verify(productService, times(1)).createProduct(product);
	}

	@Test
	@Tag("invalid")
	void verifyErrorResponseContainsCorrectStructure() {
		// Arrange
		Product product = new Product();
		product.setName("Invalid Product");
		product.setPrice(new BigDecimal("10.00"));
		// Note: Product class does not have setQuantity method.
		when(productService.createProduct(any(Product.class)))
			.thenThrow(new IllegalArgumentException("Validation failed"));
		// Act
		ResponseEntity<?> response = productController.createProduct(product);
		// Assert
		assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);
		@SuppressWarnings("unchecked")
		Map<String, String> errorResponse = (Map<String, String>) response.getBody();
		assertEquals(1, errorResponse.size());
		assertTrue(errorResponse.containsKey("error"));
		assertEquals("Validation failed", errorResponse.get("error"));
	}

}