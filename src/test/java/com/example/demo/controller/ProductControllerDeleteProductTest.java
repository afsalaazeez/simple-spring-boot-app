
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=deleteProduct_a0631e5d93
ROOST_METHOD_SIG_HASH=deleteProduct_d23872265e

Scenario 1: Successfully Delete an Existing Product

Details:
  TestName: deleteProductSuccessfullyWhenProductExists
  Description: This test verifies that when a valid product ID is provided and the product exists in the system, the deleteProduct method successfully deletes the product and returns a success response with HTTP status 200 OK.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with a valid ID (e.g., 1L), it does not throw any exception (void method completes normally). Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID 1L.
  Assert: Verify that the returned ResponseEntity has HTTP status 200 OK. Verify that the response body is a Map containing "message" with value "Product deleted successfully" and "id" with value 1L.

Validation:
  The assertion verifies that the controller correctly handles successful deletion by returning the appropriate success message and the deleted product's ID. This test is significant because it confirms the happy path scenario where a product is successfully removed from the system, which is a core functionality of the product management feature.

---

Scenario 2: Delete Product with Non-Existent ID Returns Not Found

Details:
  TestName: deleteProductReturnsNotFoundWhenProductDoesNotExist
  Description: This test verifies that when an ID is provided for a product that does not exist in the system, the deleteProduct method returns an HTTP 404 NOT_FOUND status with an appropriate error message.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with a non-existent ID (e.g., 999L), it throws an IllegalArgumentException with message "Product not found with id: 999". Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID 999L.
  Assert: Verify that the returned ResponseEntity has HTTP status 404 NOT_FOUND. Verify that the response body is a Map containing "error" key with the exception message.

Validation:
  The assertion verifies that the controller properly handles the case when attempting to delete a non-existent product by returning a 404 status and an error message. This is important for proper REST API behavior and helps clients understand why the deletion failed.

---

Scenario 3: Delete Product with Null ID

Details:
  TestName: deleteProductWithNullId
  Description: This test verifies the behavior of the deleteProduct method when a null ID is passed. The method should handle this edge case appropriately, either by throwing an exception or returning an error response.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with null, it throws an IllegalArgumentException with message "Product ID cannot be null". Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with null as the ID parameter.
  Assert: Verify that the returned ResponseEntity has HTTP status 404 NOT_FOUND. Verify that the response body contains an "error" key with the appropriate error message.

Validation:
  The assertion verifies that the controller handles null input gracefully and returns an appropriate error response. This test is significant for ensuring robust input validation and preventing null pointer exceptions in the application.

---

Scenario 4: Delete Product with Zero ID

Details:
  TestName: deleteProductWithZeroId
  Description: This test verifies the behavior of the deleteProduct method when an ID of zero is provided, which is typically an invalid product ID.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with 0L, it throws an IllegalArgumentException with message "Invalid product ID: 0". Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID 0L.
  Assert: Verify that the returned ResponseEntity has HTTP status 404 NOT_FOUND. Verify that the response body contains an "error" key with the appropriate error message.

Validation:
  The assertion verifies that the controller properly rejects invalid ID values like zero. This is important for maintaining data integrity and ensuring that only valid product IDs are processed.

---

Scenario 5: Delete Product with Negative ID

Details:
  TestName: deleteProductWithNegativeId
  Description: This test verifies the behavior of the deleteProduct method when a negative ID is provided, which is an invalid product ID.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with -1L, it throws an IllegalArgumentException with message "Invalid product ID: -1". Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID -1L.
  Assert: Verify that the returned ResponseEntity has HTTP status 404 NOT_FOUND. Verify that the response body contains an "error" key with the appropriate error message.

Validation:
  The assertion verifies that the controller properly handles negative ID values by returning an error response. This test ensures that the API rejects semantically invalid inputs.

---

Scenario 6: Delete Product with Maximum Long Value ID

Details:
  TestName: deleteProductWithMaxLongId
  Description: This test verifies the behavior of the deleteProduct method when the maximum possible Long value is provided as the ID, testing boundary conditions.

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that when deleteProduct is called with Long.MAX_VALUE, it throws an IllegalArgumentException with message "Product not found with id: 9223372036854775807". Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with Long.MAX_VALUE as the ID.
  Assert: Verify that the returned ResponseEntity has HTTP status 404 NOT_FOUND. Verify that the response body contains an "error" key with the appropriate error message.

Validation:
  The assertion verifies that the controller handles extreme boundary values correctly. This test is important for ensuring the system behaves predictably with edge case inputs.

---

Scenario 7: Verify ProductService deleteProduct Method is Called

Details:
  TestName: deleteProductCallsServiceDeleteMethod
  Description: This test verifies that the deleteProduct controller method correctly delegates the deletion operation to the ProductService's deleteProduct method with the correct ID parameter.

Execution:
  Arrange: Create a mock of ProductService. Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID 5L.
  Assert: Verify that productService.deleteProduct(5L) was called exactly once. Verify that the returned ResponseEntity has HTTP status 200 OK.

Validation:
  The assertion verifies that the controller properly delegates to the service layer. This test is significant for ensuring proper separation of concerns and that the controller acts as a thin layer that coordinates between the HTTP layer and the business logic layer.

---

Scenario 8: Delete Product Response Contains Correct Keys

Details:
  TestName: deleteProductResponseContainsMessageAndIdKeys
  Description: This test verifies that the successful deletion response contains exactly the expected keys: "message" and "id".

Execution:
  Arrange: Create a mock of ProductService. Configure the mock so that deleteProduct completes successfully. Instantiate ProductController with the mocked ProductService.
  Act: Invoke the deleteProduct method on the controller with the ID 10L.
  Assert: Verify that the response body is a Map with exactly two entries. Verify that the Map contains the key "message". Verify that the Map contains the key "id". Verify that the values are "Product deleted successfully" and 10L respectively.

Validation:
  The assertion verifies the exact structure of the success response. This is important for API contract compliance, ensuring that clients can reliably parse the response.

*/

// ********RoostGPT********

package com.example.demo.controller;

import com.example.demo.model.Product;
import com.example.demo.service.ProductService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.web.bind.annotation.*;
import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;

@ExtendWith(MockitoExtension.class)
class ProductControllerDeleteProductTest {

	@Mock
	private ProductService productService;

	private ProductController productController;

	@BeforeEach
	void setUp() {
		productController = new ProductController(productService);
	}

	@Test
	@Tag("valid")
	void deleteProductSuccessfullyWhenProductExists() {
		// Arrange
		Long productId = 1L;
		doNothing().when(productService).deleteProduct(productId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(productId);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, Object> responseBody = (Map<String, Object>) response.getBody();
		assertEquals("Product deleted successfully", responseBody.get("message"));
		assertEquals(productId, responseBody.get("id"));

		verify(productService, times(1)).deleteProduct(productId);
	}

	@Test
	@Tag("invalid")
	void deleteProductReturnsNotFoundWhenProductDoesNotExist() {
		// Arrange
		Long nonExistentId = 999L;
		doThrow(new IllegalArgumentException("Product not found with id: 999")).when(productService)
			.deleteProduct(nonExistentId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(nonExistentId);
		// Assert
		assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, String> responseBody = (Map<String, String>) response.getBody();
		assertEquals("Product not found with id: 999", responseBody.get("error"));

		verify(productService, times(1)).deleteProduct(nonExistentId);
	}

	@Test
	@Tag("invalid")
	void deleteProductWithNullId() {
		// Arrange
		Long nullId = null;
		doThrow(new IllegalArgumentException("Product ID cannot be null")).when(productService).deleteProduct(nullId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(nullId);
		// Assert
		assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, String> responseBody = (Map<String, String>) response.getBody();
		assertEquals("Product ID cannot be null", responseBody.get("error"));

		verify(productService, times(1)).deleteProduct(nullId);
	}

	@Test
	@Tag("boundary")
	void deleteProductWithZeroId() {
		// Arrange
		Long zeroId = 0L;
		doThrow(new IllegalArgumentException("Invalid product ID: 0")).when(productService).deleteProduct(zeroId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(zeroId);
		// Assert
		assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, String> responseBody = (Map<String, String>) response.getBody();
		assertEquals("Invalid product ID: 0", responseBody.get("error"));

		verify(productService, times(1)).deleteProduct(zeroId);
	}

	@Test
	@Tag("boundary")
	void deleteProductWithNegativeId() {
		// Arrange
		Long negativeId = -1L;
		doThrow(new IllegalArgumentException("Invalid product ID: -1")).when(productService).deleteProduct(negativeId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(negativeId);
		// Assert
		assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, String> responseBody = (Map<String, String>) response.getBody();
		assertEquals("Invalid product ID: -1", responseBody.get("error"));

		verify(productService, times(1)).deleteProduct(negativeId);
	}

	@Test
	@Tag("boundary")
	void deleteProductWithMaxLongId() {
		// Arrange
		Long maxLongId = Long.MAX_VALUE;
		doThrow(new IllegalArgumentException("Product not found with id: " + Long.MAX_VALUE)).when(productService)
			.deleteProduct(maxLongId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(maxLongId);
		// Assert
		assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, String> responseBody = (Map<String, String>) response.getBody();
		assertEquals("Product not found with id: " + Long.MAX_VALUE, responseBody.get("error"));

		verify(productService, times(1)).deleteProduct(maxLongId);
	}

	@Test
	@Tag("integration")
	void deleteProductCallsServiceDeleteMethod() {
		// Arrange
		Long productId = 5L;
		doNothing().when(productService).deleteProduct(productId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(productId);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		verify(productService, times(1)).deleteProduct(productId);
		verifyNoMoreInteractions(productService);
	}

	@Test
	@Tag("valid")
	void deleteProductResponseContainsMessageAndIdKeys() {
		// Arrange
		Long productId = 10L;
		doNothing().when(productService).deleteProduct(productId);
		// Act
		ResponseEntity<?> response = productController.deleteProduct(productId);
		// Assert
		assertEquals(HttpStatus.OK, response.getStatusCode());
		assertNotNull(response.getBody());
		assertTrue(response.getBody() instanceof Map);

		@SuppressWarnings("unchecked")
		Map<String, Object> responseBody = (Map<String, Object>) response.getBody();

		assertEquals(2, responseBody.size());
		assertTrue(responseBody.containsKey("message"));
		assertTrue(responseBody.containsKey("id"));
		assertEquals("Product deleted successfully", responseBody.get("message"));
		assertEquals(productId, responseBody.get("id"));
	}

}