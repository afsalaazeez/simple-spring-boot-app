
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=addCorsMappings_7380af8def
ROOST_METHOD_SIG_HASH=addCorsMappings_903608b3cd

Scenario 1: Verify CORS Mapping is Added for API Path Pattern

Details:
  TestName: corsMappingAddedForApiPathPattern
  Description: This test verifies that the addCorsMappings method correctly registers a CORS mapping for the "/api/**" path pattern. The test ensures that the CorsRegistry receives the expected path pattern configuration.

Execution:
  Arrange: Create a mock CorsRegistry object and a mock CorsRegistration object. Configure the mock CorsRegistry to return the mock CorsRegistration when addMapping is called.
  Act: Invoke the addCorsMappings method on the AppConfig instance, passing the mock CorsRegistry.
  Assert: Verify that registry.addMapping("/api/**") was called exactly once.

Validation:
  The assertion verifies that the CORS configuration targets the correct API path pattern "/api/**". This is significant because it ensures all API endpoints under the /api/ path will have CORS headers applied, enabling cross-origin requests to reach these endpoints.


Scenario 2: Verify All Origins Are Allowed

Details:
  TestName: allOriginsAllowedInCorsConfiguration
  Description: This test verifies that the CORS configuration allows requests from any origin by setting allowedOrigins to "*". This is important for development environments where the frontend may be served from different origins.

Execution:
  Arrange: Create a mock CorsRegistry and CorsRegistration. Set up the mock chain to return appropriate objects for method chaining.
  Act: Call the addCorsMappings method with the mock CorsRegistry.
  Assert: Verify that allowedOrigins("*") was called on the CorsRegistration object.

Validation:
  The assertion confirms that the wildcard "*" is used for allowed origins, permitting cross-origin requests from any domain. This is crucial for API accessibility during development, though production environments should restrict this to specific trusted origins.


Scenario 3: Verify Allowed HTTP Methods Configuration

Details:
  TestName: httpMethodsCorrectlyConfigured
  Description: This test ensures that the CORS configuration permits the correct HTTP methods: GET, POST, PUT, DELETE, and PATCH. These methods cover standard RESTful API operations.

Execution:
  Arrange: Set up mock CorsRegistry and CorsRegistration objects with proper method chaining support.
  Act: Execute the addCorsMappings method on the AppConfig instance.
  Assert: Verify that allowedMethods was called with the arguments "GET", "POST", "PUT", "DELETE", "PATCH".

Validation:
  The assertion validates that all standard RESTful HTTP methods are permitted. This is essential for a fully functional REST API that supports create (POST), read (GET), update (PUT/PATCH), and delete (DELETE) operations across different origins.


Scenario 4: Verify All Headers Are Allowed

Details:
  TestName: allHeadersAllowedInCorsConfiguration
  Description: This test verifies that the CORS configuration allows all request headers by setting allowedHeaders to "*". This ensures that clients can send any custom headers with their requests.

Execution:
  Arrange: Create mock objects for CorsRegistry and CorsRegistration with appropriate method chaining.
  Act: Invoke addCorsMappings with the prepared mock CorsRegistry.
  Assert: Verify that allowedHeaders("*") was called on the CorsRegistration.

Validation:
  The assertion confirms that all headers are permitted in cross-origin requests. This is important for APIs that may require custom headers such as authentication tokens, content-type specifications, or other application-specific headers.


Scenario 5: Verify Max Age Configuration for Preflight Cache

Details:
  TestName: maxAgeSetToOneHour
  Description: This test verifies that the CORS preflight response cache duration is set to 3600 seconds (1 hour). This optimization reduces the number of preflight OPTIONS requests by allowing browsers to cache the CORS configuration.

Execution:
  Arrange: Set up mock CorsRegistry and CorsRegistration objects that support the full method chain.
  Act: Call the addCorsMappings method on the AppConfig instance.
  Assert: Verify that maxAge(3600) was called on the CorsRegistration object.

Validation:
  The assertion validates that the preflight cache duration is set to 3600 seconds. This is significant for performance optimization as it reduces network overhead by allowing browsers to cache CORS preflight responses for one hour, minimizing redundant OPTIONS requests.


Scenario 6: Verify Complete Method Chain Execution

Details:
  TestName: completeMethodChainExecutedInOrder
  Description: This test ensures that all CORS configuration methods are called in the correct sequence: addMapping, allowedOrigins, allowedMethods, allowedHeaders, and maxAge. This validates the complete configuration flow.

Execution:
  Arrange: Create mock CorsRegistry and CorsRegistration with InOrder verification support. Configure mocks to return themselves for method chaining.
  Act: Execute the addCorsMappings method with the mock CorsRegistry.
  Assert: Use InOrder verification to confirm the methods are called in sequence: addMapping → allowedOrigins → allowedMethods → allowedHeaders → maxAge.

Validation:
  The assertion verifies the complete and correct execution of the CORS configuration chain. This is important to ensure that the Spring framework receives all necessary CORS settings in the expected order, guaranteeing proper cross-origin request handling.


Scenario 7: Verify Method Does Not Throw Exception with Valid Registry

Details:
  TestName: noExceptionThrownWithValidRegistry
  Description: This test verifies that the addCorsMappings method executes without throwing any exceptions when provided with a valid CorsRegistry instance. This confirms the method's stability under normal conditions.

Execution:
  Arrange: Create a properly configured mock CorsRegistry that supports the full method chain without throwing exceptions.
  Act: Call addCorsMappings and capture any potential exceptions.
  Assert: Assert that no exception is thrown during method execution.

Validation:
  The assertion confirms that the CORS configuration method is stable and does not produce runtime errors. This is essential for application startup reliability, as CORS configuration failures could prevent the application from properly handling cross-origin requests.


Scenario 8: Verify WebMvcConfigurer Interface Implementation

Details:
  TestName: appConfigImplementsWebMvcConfigurer
  Description: This test verifies that the AppConfig class properly implements the WebMvcConfigurer interface, which is required for Spring MVC configuration customization including CORS settings.

Execution:
  Arrange: Create an instance of the AppConfig class.
  Act: Check if the instance is of type WebMvcConfigurer.
  Assert: Assert that the AppConfig instance is an instance of WebMvcConfigurer.

Validation:
  The assertion confirms that AppConfig correctly implements the WebMvcConfigurer interface. This is crucial because Spring relies on this interface to detect and apply custom MVC configurations, including the CORS mappings defined in the addCorsMappings method.

*/

// ********RoostGPT********

package com.example.demo.config;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InOrder;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;

@ExtendWith(MockitoExtension.class)
class AppConfigAddCorsMappingsTest {

	private AppConfig appConfig;

	@Mock
	private CorsRegistry corsRegistry;

	@Mock
	private CorsRegistration corsRegistration;

	@BeforeEach
	void setUp() {
		appConfig = new AppConfig();
	}

	@Test
    @Tag("valid")
    void corsMappingAddedForApiPathPattern() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        verify(corsRegistry, times(1)).addMapping("/api/**");
    }

	@Test
    @Tag("valid")
    void allOriginsAllowedInCorsConfiguration() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        verify(corsRegistration, times(1)).allowedOrigins("*");
    }

	@Test
    @Tag("valid")
    void httpMethodsCorrectlyConfigured() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        verify(corsRegistration, times(1)).allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH");
    }

	@Test
    @Tag("valid")
    void allHeadersAllowedInCorsConfiguration() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        verify(corsRegistration, times(1)).allowedHeaders("*");
    }

	@Test
    @Tag("valid")
    void maxAgeSetToOneHour() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        verify(corsRegistration, times(1)).maxAge(3600);
    }

	@Test
    @Tag("valid")
    void completeMethodChainExecutedInOrder() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act
        appConfig.addCorsMappings(corsRegistry);
        // Assert
        InOrder inOrder = inOrder(corsRegistry, corsRegistration);
        inOrder.verify(corsRegistry).addMapping("/api/**");
        inOrder.verify(corsRegistration).allowedOrigins("*");
        inOrder.verify(corsRegistration).allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH");
        inOrder.verify(corsRegistration).allowedHeaders("*");
        inOrder.verify(corsRegistration).maxAge(3600);
    }

	@Test
    @Tag("valid")
    void noExceptionThrownWithValidRegistry() {
        // Arrange
        when(corsRegistry.addMapping("/api/**")).thenReturn(corsRegistration);
        when(corsRegistration.allowedOrigins("*")).thenReturn(corsRegistration);
        when(corsRegistration.allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")).thenReturn(corsRegistration);
        when(corsRegistration.allowedHeaders("*")).thenReturn(corsRegistration);
        when(corsRegistration.maxAge(3600)).thenReturn(corsRegistration);
        // Act & Assert
        assertDoesNotThrow(() -> appConfig.addCorsMappings(corsRegistry));
    }

	@Test
	@Tag("valid")
	void appConfigImplementsWebMvcConfigurer() {
		// Arrange
		AppConfig config = new AppConfig();
		// Act & Assert
		assertTrue(config instanceof WebMvcConfigurer);
	}

}