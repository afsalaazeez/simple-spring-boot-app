
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=saveWithValidation_e81fb690d8
ROOST_METHOD_SIG_HASH=saveWithValidation_ec756050bb

Scenario 1: Save a New User Without an ID

Details:
  TestName: saveNewUserWithoutId
  Description: Verify that a new user without an ID is saved successfully and assigned a generated ID, regardless of the allowUpdate flag.

Execution:
  Arrange: Create a new User object without setting an ID (ID is null). Set allowUpdate to false.
  Act: Call saveWithValidation(user, false).
  Assert: Verify that the returned user has a non-null ID and that the user exists in the repository.

Validation:
  The assertion verifies that when a user has no ID, the save method generates one and stores the user. This is important because new users should always be saveable without triggering the existence check, as they don't have an ID to check against.

---

Scenario 2: Save a New User Without an ID with AllowUpdate True

Details:
  TestName: saveNewUserWithoutIdAllowUpdateTrue
  Description: Verify that a new user without an ID is saved successfully when allowUpdate is true.

Execution:
  Arrange: Create a new User object without setting an ID (ID is null). Set allowUpdate to true.
  Act: Call saveWithValidation(user, true).
  Assert: Verify that the returned user has a non-null ID and the user is stored in the repository.

Validation:
  The assertion confirms that the allowUpdate flag does not affect the saving of new users without IDs. This ensures consistent behavior for new user creation regardless of the update flag.

---

Scenario 3: Update an Existing User with AllowUpdate True

Details:
  TestName: updateExistingUserWithAllowUpdateTrue
  Description: Verify that an existing user can be updated when allowUpdate is set to true.

Execution:
  Arrange: First save a user to get an assigned ID. Then modify the user's data (e.g., change name or email). Set allowUpdate to true.
  Act: Call saveWithValidation(modifiedUser, true).
  Assert: Verify that the method returns the updated user and the changes are persisted in the repository.

Validation:
  The assertion verifies that when allowUpdate is true, existing users can be modified and saved without throwing an exception. This is critical for supporting user profile updates in the application.

---

Scenario 4: Attempt to Save Existing User with AllowUpdate False Throws Exception

Details:
  TestName: saveExistingUserWithAllowUpdateFalseThrowsException
  Description: Verify that attempting to save a user with an existing ID when allowUpdate is false throws an IllegalStateException.

Execution:
  Arrange: First save a user to get an assigned ID. Create or modify a user object with the same ID. Set allowUpdate to false.
  Act: Call saveWithValidation(userWithExistingId, false).
  Assert: Verify that an IllegalStateException is thrown with a message containing "User already exists with id:".

Validation:
  The assertion confirms that the method properly prevents duplicate user creation when updates are not allowed. This protects data integrity by ensuring users cannot accidentally overwrite existing records.

---

Scenario 5: Save User with Non-Existing ID and AllowUpdate False

Details:
  TestName: saveUserWithNonExistingIdAllowUpdateFalse
  Description: Verify that a user with a manually set ID that does not exist in the repository can be saved when allowUpdate is false.

Execution:
  Arrange: Create a new User object and manually set an ID that does not exist in the repository (e.g., a very large number like 9999L). Set allowUpdate to false.
  Act: Call saveWithValidation(user, false).
  Assert: Verify that the user is saved successfully with the specified ID.

Validation:
  The assertion verifies that the existence check only blocks saving when the ID actually exists in the repository. Users with new, non-conflicting IDs should be saveable even with allowUpdate set to false.

---

Scenario 6: Save User with Non-Existing ID and AllowUpdate True

Details:
  TestName: saveUserWithNonExistingIdAllowUpdateTrue
  Description: Verify that a user with a manually set ID that does not exist can be saved when allowUpdate is true.

Execution:
  Arrange: Create a new User object and manually set an ID that does not exist in the repository. Set allowUpdate to true.
  Act: Call saveWithValidation(user, true).
  Assert: Verify that the user is saved successfully with the specified ID.

Validation:
  The assertion confirms that users with new IDs can be saved regardless of the allowUpdate flag. This supports scenarios where IDs might be pre-assigned from external systems.

---

Scenario 7: Exception Message Contains Correct User ID

Details:
  TestName: exceptionMessageContainsCorrectUserId
  Description: Verify that the IllegalStateException message includes the correct user ID when attempting to save an existing user with allowUpdate false.

Execution:
  Arrange: Save a user and note the assigned ID. Attempt to save another user with the same ID with allowUpdate set to false.
  Act: Call saveWithValidation(userWithSameId, false) and catch the exception.
  Assert: Verify that the exception message contains the specific user ID.

Validation:
  The assertion ensures that error messages are informative and include the conflicting ID, which aids in debugging and provides clear feedback to API consumers about why the operation failed.

---

Scenario 8: Save Multiple New Users Sequentially

Details:
  TestName: saveMultipleNewUsersSequentially
  Description: Verify that multiple new users can be saved sequentially, each receiving a unique auto-generated ID.

Execution:
  Arrange: Create multiple User objects without IDs.
  Act: Call saveWithValidation for each user with allowUpdate set to false.
  Assert: Verify that each user receives a unique ID and all users are stored in the repository.

Validation:
  The assertion confirms that the ID generation mechanism works correctly for multiple saves, ensuring no ID collisions occur. This is essential for maintaining data integrity in concurrent environments.

---

Scenario 9: Update User Data Preserves ID

Details:
  TestName: updateUserDataPreservesId
  Description: Verify that when updating an existing user with allowUpdate true, the user's ID remains unchanged.

Execution:
  Arrange: Save a user and record the assigned ID. Modify the user's other attributes.
  Act: Call saveWithValidation(modifiedUser, true).
  Assert: Verify that the returned user has the same ID as before the update.

Validation:
  The assertion ensures that updates do not accidentally change the user's identity. Preserving IDs is crucial for maintaining referential integrity across the application.

---

Scenario 10: Save User with Null ID After Repository Has Existing Users

Details:
  TestName: saveUserWithNullIdAfterExistingUsers
  Description: Verify that a new user with null ID is assigned the next available ID when the repository already contains users.

Execution:
  Arrange: Ensure the repository has existing users (from constructor initialization). Create a new User without an ID.
  Act: Call saveWithValidation(newUser, false).
  Assert: Verify that the new user receives an ID greater than existing user IDs.

Validation:
  The assertion confirms that the AtomicLong ID generator correctly increments and assigns unique IDs even when the repository is pre-populated. This prevents ID conflicts with existing data.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositorySaveWithValidationTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void saveNewUserWithoutId() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		// Act
		User savedUser = userRepository.saveWithValidation(newUser, false);
		// Assert
		assertNotNull(savedUser.getId());
		assertTrue(userRepository.existsById(savedUser.getId()));
		assertEquals("Test User", savedUser.getName());
		assertEquals("test@example.com", savedUser.getEmail());
	}

	@Test
	@Tag("valid")
	void saveNewUserWithoutIdAllowUpdateTrue() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		// Act
		User savedUser = userRepository.saveWithValidation(newUser, true);
		// Assert
		assertNotNull(savedUser.getId());
		assertTrue(userRepository.existsById(savedUser.getId()));
		assertEquals("Test User", savedUser.getName());
	}

	@Test
	@Tag("valid")
	void updateExistingUserWithAllowUpdateTrue() {
		// Arrange
		User initialUser = new User("Initial Name", "initial@example.com", "USER");
		User savedUser = userRepository.saveWithValidation(initialUser, false);
		Long userId = savedUser.getId();

		savedUser.setName("Updated Name");
		savedUser.setEmail("updated@example.com");
		// Act
		User updatedUser = userRepository.saveWithValidation(savedUser, true);
		// Assert
		assertEquals(userId, updatedUser.getId());
		assertEquals("Updated Name", updatedUser.getName());
		assertEquals("updated@example.com", updatedUser.getEmail());
		assertTrue(userRepository.findById(userId).isPresent());
		assertEquals("Updated Name", userRepository.findById(userId).get().getName());
	}

	@Test
	@Tag("invalid")
	void saveExistingUserWithAllowUpdateFalseThrowsException() {
		// Arrange
		User initialUser = new User("Test User", "test@example.com", "USER");
		User savedUser = userRepository.saveWithValidation(initialUser, false);
		Long existingId = savedUser.getId();

		User duplicateUser = new User("Duplicate User", "duplicate@example.com", "USER");
		duplicateUser.setId(existingId);
		// Act & Assert
		IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
			userRepository.saveWithValidation(duplicateUser, false);
		});

		assertTrue(exception.getMessage().contains("User already exists with id:"));
	}

	@Test
	@Tag("valid")
	void saveUserWithNonExistingIdAllowUpdateFalse() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		newUser.setId(9999L);
		// Act
		User savedUser = userRepository.saveWithValidation(newUser, false);
		// Assert
		assertEquals(9999L, savedUser.getId());
		assertTrue(userRepository.existsById(9999L));
	}

	@Test
	@Tag("valid")
	void saveUserWithNonExistingIdAllowUpdateTrue() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		newUser.setId(8888L);
		// Act
		User savedUser = userRepository.saveWithValidation(newUser, true);
		// Assert
		assertEquals(8888L, savedUser.getId());
		assertTrue(userRepository.existsById(8888L));
	}

	@Test
	@Tag("invalid")
	void exceptionMessageContainsCorrectUserId() {
		// Arrange
		User initialUser = new User("Test User", "test@example.com", "USER");
		User savedUser = userRepository.saveWithValidation(initialUser, false);
		Long existingId = savedUser.getId();

		User duplicateUser = new User("Duplicate User", "duplicate@example.com", "USER");
		duplicateUser.setId(existingId);
		// Act & Assert
		IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
			userRepository.saveWithValidation(duplicateUser, false);
		});

		assertTrue(exception.getMessage().contains(existingId.toString()));
	}

	@Test
	@Tag("valid")
	void saveMultipleNewUsersSequentially() {
		// Arrange
		User user1 = new User("User One", "user1@example.com", "USER");
		User user2 = new User("User Two", "user2@example.com", "USER");
		User user3 = new User("User Three", "user3@example.com", "ADMIN");
		// Act
		User savedUser1 = userRepository.saveWithValidation(user1, false);
		User savedUser2 = userRepository.saveWithValidation(user2, false);
		User savedUser3 = userRepository.saveWithValidation(user3, false);
		// Assert
		assertNotNull(savedUser1.getId());
		assertNotNull(savedUser2.getId());
		assertNotNull(savedUser3.getId());

		assertNotEquals(savedUser1.getId(), savedUser2.getId());
		assertNotEquals(savedUser2.getId(), savedUser3.getId());
		assertNotEquals(savedUser1.getId(), savedUser3.getId());

		assertTrue(userRepository.existsById(savedUser1.getId()));
		assertTrue(userRepository.existsById(savedUser2.getId()));
		assertTrue(userRepository.existsById(savedUser3.getId()));
	}

	@Test
	@Tag("valid")
	void updateUserDataPreservesId() {
		// Arrange
		User initialUser = new User("Initial Name", "initial@example.com", "USER");
		User savedUser = userRepository.saveWithValidation(initialUser, false);
		Long originalId = savedUser.getId();

		savedUser.setName("Modified Name");
		savedUser.setEmail("modified@example.com");
		savedUser.setRole("ADMIN");
		// Act
		User updatedUser = userRepository.saveWithValidation(savedUser, true);
		// Assert
		assertEquals(originalId, updatedUser.getId());
		assertEquals("Modified Name", updatedUser.getName());
		assertEquals("modified@example.com", updatedUser.getEmail());
		assertEquals("ADMIN", updatedUser.getRole());
	}

	@Test
	@Tag("boundary")
	void saveUserWithNullIdAfterExistingUsers() {
		// Arrange - Repository already has users from constructor (IDs 1, 2, 3)
		long initialCount = userRepository.count();
		User newUser = new User("New User", "newuser@example.com", "USER");
		// Act
		User savedUser = userRepository.saveWithValidation(newUser, false);
		// Assert
		assertNotNull(savedUser.getId());
		assertTrue(savedUser.getId() > 0);
		assertEquals(initialCount + 1, userRepository.count());
		assertTrue(userRepository.existsById(savedUser.getId()));
	}

}