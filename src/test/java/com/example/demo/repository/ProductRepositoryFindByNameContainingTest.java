
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findByNameContaining_255b34584f
ROOST_METHOD_SIG_HASH=findByNameContaining_739e7ba865

Scenario 1: Find Products by Exact Name Match (Case Insensitive)

Details:
  TestName: findProductsByExactNameMatchCaseInsensitive
  Description: Verify that the method returns products when the search string exactly matches a product name, regardless of case differences.
Execution:
  Arrange: Use the default ProductRepository which is initialized with sample data including "Laptop", "Mouse", "Keyboard", "Monitor", and "Headphones".
  Act: Invoke findByNameContaining with "laptop" (lowercase).
  Assert: Verify that the returned list contains exactly one product and that product's name is "Laptop".
Validation:
  The assertion verifies that the case-insensitive search works correctly when the search term matches a product name exactly but with different casing. This is important for user-friendly search functionality where users shouldn't need to worry about capitalization.

---

Scenario 2: Find Products by Partial Name Match

Details:
  TestName: findProductsByPartialNameMatch
  Description: Verify that the method returns products when the search string is a substring of the product name.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "board" as the search parameter.
  Assert: Verify that the returned list contains exactly one product with the name "Keyboard".
Validation:
  The assertion confirms that partial string matching works correctly, allowing users to find products without knowing the complete product name. This enhances the search experience by providing flexible matching capabilities.

---

Scenario 3: Find Multiple Products Matching Search Criteria

Details:
  TestName: findMultipleProductsMatchingSearchCriteria
  Description: Verify that the method returns all products whose names contain the search string when multiple matches exist.
Execution:
  Arrange: Create a new ProductRepository and save additional products with similar names, such as "Gaming Mouse" and "Office Mouse".
  Act: Invoke findByNameContaining with "Mouse".
  Assert: Verify that the returned list contains all products with "Mouse" in their name.
Validation:
  The assertion ensures that the method returns all matching products, not just the first match. This is critical for search functionality to provide comprehensive results to users.

---

Scenario 4: Find Products with Empty Search String

Details:
  TestName: findProductsWithEmptySearchString
  Description: Verify that the method returns all products when an empty string is provided as the search parameter.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data containing 5 products.
  Act: Invoke findByNameContaining with an empty string "".
  Assert: Verify that the returned list contains all 5 products from the repository.
Validation:
  The assertion verifies that an empty search string matches all products since every string contains an empty string. This behavior should be understood and potentially handled at the service layer if different behavior is desired.

---

Scenario 5: Find Products with No Matching Results

Details:
  TestName: findProductsWithNoMatchingResults
  Description: Verify that the method returns an empty list when no products match the search criteria.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "XYZ123NonExistent".
  Assert: Verify that the returned list is empty (size equals 0).
Validation:
  The assertion confirms that the method gracefully handles cases where no products match the search criteria by returning an empty list rather than null. This prevents NullPointerException in calling code.

---

Scenario 6: Find Products with Mixed Case Search String

Details:
  TestName: findProductsWithMixedCaseSearchString
  Description: Verify that the method correctly handles search strings with mixed uppercase and lowercase characters.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "MoNiToR" (mixed case).
  Assert: Verify that the returned list contains exactly one product with the name "Monitor".
Validation:
  The assertion ensures that the case-insensitive comparison works correctly regardless of how the search string is capitalized. This provides a consistent user experience.

---

Scenario 7: Find Products with Single Character Search

Details:
  TestName: findProductsWithSingleCharacterSearch
  Description: Verify that the method returns all products containing a single character in their names.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "o" as the search parameter.
  Assert: Verify that the returned list contains products whose names contain the letter "o" (Mouse, Monitor, Keyboard, Headphones).
Validation:
  The assertion verifies that single character searches work correctly and return all products containing that character. This tests the minimum viable search input.

---

Scenario 8: Find Products with Special Characters in Search String

Details:
  TestName: findProductsWithSpecialCharactersInSearchString
  Description: Verify that the method handles search strings containing special characters without errors.
Execution:
  Arrange: Create a ProductRepository and save a product with a name containing special characters, such as "USB-C Cable".
  Act: Invoke findByNameContaining with "-C".
  Assert: Verify that the returned list contains the product "USB-C Cable".
Validation:
  The assertion confirms that special characters in the search string are handled correctly without causing regex or parsing errors. This is important for products with technical naming conventions.

---

Scenario 9: Find Products with Whitespace in Search String

Details:
  TestName: findProductsWithWhitespaceInSearchString
  Description: Verify that the method correctly handles search strings containing whitespace.
Execution:
  Arrange: Use the default ProductRepository which contains "Wireless mouse" in the description but "Mouse" as the name.
  Act: Invoke findByNameContaining with "se" (partial match).
  Assert: Verify that the returned list contains the "Mouse" product.
Validation:
  The assertion ensures that the search operates on product names and handles partial matches correctly. Whitespace handling is important for multi-word product names.

---

Scenario 10: Find Products from Empty Repository

Details:
  TestName: findProductsFromEmptyRepository
  Description: Verify that the method returns an empty list when the repository contains no products.
Execution:
  Arrange: Create a new ProductRepository and remove all products by calling deleteById for each existing product, or access the products map if possible to clear it.
  Act: Invoke findByNameContaining with any search string like "Laptop".
  Assert: Verify that the returned list is empty.
Validation:
  The assertion confirms that the method handles an empty repository gracefully without throwing exceptions. This edge case is important for newly initialized or cleared repositories.

---

Scenario 11: Find Products with Numeric Characters in Name

Details:
  TestName: findProductsWithNumericCharactersInName
  Description: Verify that the method correctly finds products when the search string contains numeric characters.
Execution:
  Arrange: Create a ProductRepository and save a product with a name containing numbers, such as "Monitor 27".
  Act: Invoke findByNameContaining with "27".
  Assert: Verify that the returned list contains the product "Monitor 27".
Validation:
  The assertion ensures that numeric characters in product names are searchable. This is common for products with model numbers or specifications in their names.

---

Scenario 12: Find Products with Leading and Trailing Spaces in Search

Details:
  TestName: findProductsWithLeadingAndTrailingSpacesInSearch
  Description: Verify that the method handles search strings with leading or trailing spaces.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with " Mouse " (with spaces).
  Assert: Verify that the returned list is empty since no product name contains " Mouse " with spaces.
Validation:
  The assertion confirms that the method performs literal string matching including spaces. This behavior should be documented or handled at the service layer if trimming is desired.

---

Scenario 13: Verify Returned List is Immutable

Details:
  TestName: verifyReturnedListIsImmutable
  Description: Verify that the list returned by findByNameContaining is immutable (as toList() returns an unmodifiable list in Java 16+).
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "Mouse" and attempt to add a new product to the returned list.
  Assert: Verify that an UnsupportedOperationException is thrown when attempting to modify the returned list.
Validation:
  The assertion confirms that the returned list cannot be modified, which protects the internal state of the repository from unintended modifications through the returned collection.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryFindByNameContainingTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void findProductsByExactNameMatchCaseInsensitive() {
		// Arrange: Use the default ProductRepository which is initialized with sample
		// data

		// Act: Invoke findByNameContaining with "laptop" (lowercase)
		List<Product> result = productRepository.findByNameContaining("laptop");

		// Assert: Verify that the returned list contains exactly one product and that
		// product's name is "Laptop"
		assertEquals(1, result.size());
		assertEquals("Laptop", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsByPartialNameMatch() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with "board" as the search parameter
		List<Product> result = productRepository.findByNameContaining("board");

		// Assert: Verify that the returned list contains exactly one product with the
		// name "Keyboard"
		assertEquals(1, result.size());
		assertEquals("Keyboard", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findMultipleProductsMatchingSearchCriteria() {
		// Arrange: Create a new ProductRepository and save additional products with
		// similar names
		productRepository.save(new Product("Gaming Mouse", "High precision gaming mouse", new BigDecimal("59.99"), 40));
		productRepository.save(new Product("Office Mouse", "Ergonomic office mouse", new BigDecimal("24.99"), 60));

		// Act: Invoke findByNameContaining with "Mouse"
		List<Product> result = productRepository.findByNameContaining("Mouse");

		// Assert: Verify that the returned list contains all products with "Mouse" in
		// their name
		assertEquals(3, result.size());
		assertTrue(result.stream().allMatch(p -> p.getName().toLowerCase().contains("mouse")));
	}

	@Test
	@Tag("boundary")
	void findProductsWithEmptySearchString() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data
		// containing 5 products

		// Act: Invoke findByNameContaining with an empty string ""
		List<Product> result = productRepository.findByNameContaining("");

		// Assert: Verify that the returned list contains all 5 products from the
		// repository
		assertEquals(5, result.size());
	}

	@Test
	@Tag("valid")
	void findProductsWithNoMatchingResults() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with "XYZ123NonExistent"
		List<Product> result = productRepository.findByNameContaining("XYZ123NonExistent");

		// Assert: Verify that the returned list is empty (size equals 0)
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("valid")
	void findProductsWithMixedCaseSearchString() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with "MoNiToR" (mixed case)
		List<Product> result = productRepository.findByNameContaining("MoNiToR");

		// Assert: Verify that the returned list contains exactly one product with the
		// name "Monitor"
		assertEquals(1, result.size());
		assertEquals("Monitor", result.get(0).getName());
	}

	@Test
	@Tag("boundary")
	void findProductsWithSingleCharacterSearch() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with "o" as the search parameter
		List<Product> result = productRepository.findByNameContaining("o");

		// Assert: Verify that the returned list contains products whose names contain the
		// letter "o"
		assertFalse(result.isEmpty());
		assertTrue(result.stream().allMatch(p -> p.getName().toLowerCase().contains("o")));
		// Expected: Mouse, Monitor, Keyboard, Headphones
		assertEquals(4, result.size());
	}

	@Test
	@Tag("valid")
	void findProductsWithSpecialCharactersInSearchString() {
		// Arrange: Create a ProductRepository and save a product with a name containing
		// special characters
		productRepository.save(new Product("USB-C Cable", "High-speed USB-C cable", new BigDecimal("19.99"), 100));

		// Act: Invoke findByNameContaining with "-C"
		List<Product> result = productRepository.findByNameContaining("-C");

		// Assert: Verify that the returned list contains the product "USB-C Cable"
		assertEquals(1, result.size());
		assertEquals("USB-C Cable", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsWithWhitespaceInSearchString() {
		// Arrange: Use the default ProductRepository which contains "Mouse" as the name

		// Act: Invoke findByNameContaining with "se" (partial match)
		List<Product> result = productRepository.findByNameContaining("se");

		// Assert: Verify that the returned list contains the "Mouse" product
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Mouse")));
	}

	@Test
	@Tag("boundary")
	void findProductsFromEmptyRepository() {
		// Arrange: Create a new ProductRepository and remove all products
		List<Product> allProducts = productRepository.findAll();
		for (Product product : allProducts) {
			productRepository.deleteById(product.getId());
		}

		// Act: Invoke findByNameContaining with any search string like "Laptop"
		List<Product> result = productRepository.findByNameContaining("Laptop");

		// Assert: Verify that the returned list is empty
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("valid")
	void findProductsWithNumericCharactersInName() {
		// Arrange: Create a ProductRepository and save a product with a name containing
		// numbers
		productRepository.save(new Product("Monitor 27", "27-inch display", new BigDecimal("349.99"), 15));

		// Act: Invoke findByNameContaining with "27"
		List<Product> result = productRepository.findByNameContaining("27");

		// Assert: Verify that the returned list contains the product "Monitor 27"
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Monitor 27")));
	}

	@Test
	@Tag("boundary")
	void findProductsWithLeadingAndTrailingSpacesInSearch() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with " Mouse " (with spaces)
		List<Product> result = productRepository.findByNameContaining(" Mouse ");

		// Assert: Verify that the returned list is empty since no product name contains "
		// Mouse " with spaces
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("valid")
	void verifyReturnedListIsImmutable() {
		// Arrange: Use the default ProductRepository with pre-initialized sample data

		// Act: Invoke findByNameContaining with "Mouse"
		List<Product> result = productRepository.findByNameContaining("Mouse");

		// Assert: Verify that an UnsupportedOperationException is thrown when attempting
		// to modify the returned list
		assertThrows(UnsupportedOperationException.class, () -> {
			result.add(new Product("Test Mouse", "Test description", new BigDecimal("9.99"), 10));
		});
	}

}