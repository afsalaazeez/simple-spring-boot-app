
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findByNameContaining_255b34584f
ROOST_METHOD_SIG_HASH=findByNameContaining_739e7ba865

Scenario 1: Find Products by Exact Name Match (Case Insensitive)

Details:
  TestName: findProductsByExactNameMatchCaseInsensitive
  Description: Verify that the method returns products when the search string exactly matches a product name, regardless of case differences.
Execution:
  Arrange: Use the default ProductRepository which is initialized with sample data including "Laptop", "Mouse", "Keyboard", "Monitor", and "Headphones".
  Act: Invoke findByNameContaining with "laptop" (lowercase).
  Assert: Verify that the returned list contains exactly one product and that product's name is "Laptop".
Validation:
  The assertion verifies that the case-insensitive search works correctly when the search term matches a product name exactly but with different casing. This is important for user-friendly search functionality where users shouldn't need to worry about capitalization.

---

Scenario 2: Find Products by Partial Name Match

Details:
  TestName: findProductsByPartialNameMatch
  Description: Verify that the method returns products when the search string is a substring of the product name.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "board" as the search parameter.
  Assert: Verify that the returned list contains exactly one product with the name "Keyboard".
Validation:
  The assertion confirms that partial matching works correctly, allowing users to find products without knowing the complete product name. This enhances search usability in e-commerce applications.

---

Scenario 3: Find Multiple Products Matching Search Term

Details:
  TestName: findMultipleProductsMatchingSearchTerm
  Description: Verify that the method returns all products whose names contain the search string.
Execution:
  Arrange: Save additional products to the repository using save() method, such as a product named "Gaming Mouse" and "Mouse Pad".
  Act: Invoke findByNameContaining with "Mouse".
  Assert: Verify that the returned list contains all products with "Mouse" in their name (original "Mouse", "Gaming Mouse", and "Mouse Pad").
Validation:
  The assertion ensures that the method correctly identifies and returns all matching products, not just the first match. This is critical for comprehensive search results in product catalogs.

---

Scenario 4: Find Products with Empty Search String

Details:
  TestName: findProductsWithEmptySearchString
  Description: Verify that the method returns all products when an empty string is provided as the search parameter.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data containing 5 products.
  Act: Invoke findByNameContaining with an empty string "".
  Assert: Verify that the returned list contains all 5 products from the repository.
Validation:
  The assertion confirms that an empty string matches all products since every string contains an empty string. This behavior should be understood for proper UI handling of empty search queries.

---

Scenario 5: Find Products with No Matching Results

Details:
  TestName: findProductsWithNoMatchingResults
  Description: Verify that the method returns an empty list when no products match the search string.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "XYZ123NonExistent".
  Assert: Verify that the returned list is empty (size equals 0).
Validation:
  The assertion ensures that the method gracefully handles cases where no products match the search criteria by returning an empty list rather than null. This prevents NullPointerException in calling code.

---

Scenario 6: Find Products with Mixed Case Search String

Details:
  TestName: findProductsWithMixedCaseSearchString
  Description: Verify that the method correctly handles search strings with mixed uppercase and lowercase characters.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "MoNiToR" (mixed case).
  Assert: Verify that the returned list contains exactly one product with the name "Monitor".
Validation:
  The assertion verifies that the toLowerCase() conversion is applied correctly to both the search string and product names, ensuring truly case-insensitive searching.

---

Scenario 7: Find Products with Single Character Search

Details:
  TestName: findProductsWithSingleCharacterSearch
  Description: Verify that the method returns all products containing a single character in their names.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "o" as the search parameter.
  Assert: Verify that the returned list contains products whose names contain the letter "o" (Mouse, Monitor, Keyboard, Headphones).
Validation:
  The assertion confirms that single-character searches work correctly and return all matching products. This tests the boundary condition of minimal search input.

---

Scenario 8: Find Products with Special Characters in Search String

Details:
  TestName: findProductsWithSpecialCharactersInSearchString
  Description: Verify that the method handles search strings containing special characters without errors.
Execution:
  Arrange: Save a new product with a name containing special characters, such as "USB-C Cable" using the save() method.
  Act: Invoke findByNameContaining with "-C".
  Assert: Verify that the returned list contains the product "USB-C Cable".
Validation:
  The assertion ensures that special characters in search strings are handled correctly without causing regex or parsing errors. This is important for products with technical naming conventions.

---

Scenario 9: Find Products with Whitespace in Search String

Details:
  TestName: findProductsWithWhitespaceInSearchString
  Description: Verify that the method correctly handles search strings containing whitespace.
Execution:
  Arrange: Use the default ProductRepository which contains "27-inch 4K monitor" in the Monitor product description (note: searching by name, so save a product with space in name like "Gaming Mouse").
  Act: Invoke findByNameContaining with "ing M" (contains space).
  Assert: Verify that the returned list contains products matching the search term with embedded whitespace.
Validation:
  The assertion confirms that whitespace characters are treated as regular characters in the search, allowing users to search for multi-word product names accurately.

---

Scenario 10: Find Products After Adding New Product

Details:
  TestName: findProductsAfterAddingNewProduct
  Description: Verify that newly added products are included in search results.
Execution:
  Arrange: Save a new product named "Wireless Laptop Stand" using the save() method.
  Act: Invoke findByNameContaining with "Laptop".
  Assert: Verify that the returned list contains both the original "Laptop" product and the new "Wireless Laptop Stand" product.
Validation:
  The assertion ensures that the search operates on the current state of the repository and includes recently added products. This verifies the dynamic nature of the in-memory storage.

---

Scenario 11: Find Products After Deleting a Product

Details:
  TestName: findProductsAfterDeletingProduct
  Description: Verify that deleted products are not included in search results.
Execution:
  Arrange: Use findByNameContaining with "Laptop" to get the Laptop product, then delete it using deleteById() with its ID.
  Act: Invoke findByNameContaining with "Laptop" again.
  Assert: Verify that the returned list is empty.
Validation:
  The assertion confirms that the search correctly reflects the current repository state and excludes deleted products. This is essential for data consistency in the application.

---

Scenario 12: Find Products with Numeric Characters in Search String

Details:
  TestName: findProductsWithNumericCharactersInSearchString
  Description: Verify that the method handles search strings containing numeric characters.
Execution:
  Arrange: Save a new product named "USB 3.0 Hub" using the save() method.
  Act: Invoke findByNameContaining with "3.0".
  Assert: Verify that the returned list contains the product "USB 3.0 Hub".
Validation:
  The assertion ensures that numeric characters and decimal points in search strings are handled correctly, which is common in technical product names.

---

Scenario 13: Find Products with Search String at Beginning of Name

Details:
  TestName: findProductsWithSearchStringAtBeginningOfName
  Description: Verify that the method finds products when the search string matches the beginning of the product name.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "Key".
  Assert: Verify that the returned list contains the product "Keyboard".
Validation:
  The assertion confirms that the contains() method works for prefix matching, which is a common search pattern when users start typing a product name.

---

Scenario 14: Find Products with Search String at End of Name

Details:
  TestName: findProductsWithSearchStringAtEndOfName
  Description: Verify that the method finds products when the search string matches the end of the product name.
Execution:
  Arrange: Use the default ProductRepository with pre-initialized sample data.
  Act: Invoke findByNameContaining with "phones".
  Assert: Verify that the returned list contains the product "Headphones".
Validation:
  The assertion confirms that the contains() method works for suffix matching, ensuring comprehensive search coverage regardless of where the match occurs in the product name.

---

Scenario 15: Find Products in Empty Repository

Details:
  TestName: findProductsInEmptyRepository
  Description: Verify that the method returns an empty list when the repository has no products.
Execution:
  Arrange: Create a new ProductRepository instance and delete all pre-initialized products using deleteById() for each product ID (1 through 5).
  Act: Invoke findByNameContaining with any search string like "Product".
  Assert: Verify that the returned list is empty.
Validation:
  The assertion ensures that the method handles an empty repository gracefully without throwing exceptions, returning an empty list as expected.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryFindByNameContainingTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void findProductsByExactNameMatchCaseInsensitive() {
		// Arrange - repository is initialized with sample data including "Laptop"

		// Act
		List<Product> result = productRepository.findByNameContaining("laptop");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Laptop", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsByPartialNameMatch() {
		// Arrange - repository is initialized with sample data including "Keyboard"

		// Act
		List<Product> result = productRepository.findByNameContaining("board");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Keyboard", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findMultipleProductsMatchingSearchTerm() {
		// Arrange
		productRepository.save(new Product("Gaming Mouse", "Gaming mouse description", new BigDecimal("49.99"), 10));
		productRepository.save(new Product("Mouse Pad", "Mouse pad description", new BigDecimal("19.99"), 40));

		// Act
		List<Product> result = productRepository.findByNameContaining("Mouse");

		// Assert
		assertEquals(3, result.size());
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Mouse")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Gaming Mouse")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Mouse Pad")));
	}

	@Test
	@Tag("boundary")
	void findProductsWithEmptySearchString() {
		// Arrange - repository is initialized with 5 products

		// Act
		List<Product> result = productRepository.findByNameContaining("");

		// Assert
		assertEquals(5, result.size());
	}

	@Test
	@Tag("valid")
	void findProductsWithNoMatchingResults() {
		// Arrange - repository is initialized with sample data

		// Act
		List<Product> result = productRepository.findByNameContaining("XYZ123NonExistent");

		// Assert
		assertTrue(result.isEmpty());
		assertEquals(0, result.size());
	}

	@Test
	@Tag("valid")
	void findProductsWithMixedCaseSearchString() {
		// Arrange - repository is initialized with sample data including "Monitor"

		// Act
		List<Product> result = productRepository.findByNameContaining("MoNiToR");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Monitor", result.get(0).getName());
	}

	@Test
	@Tag("boundary")
	void findProductsWithSingleCharacterSearch() {
		// Arrange - repository is initialized with sample data

		// Act
		List<Product> result = productRepository.findByNameContaining("o");

		// Assert
		assertFalse(result.isEmpty());
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Mouse")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Monitor")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Keyboard")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Headphones")));
	}

	@Test
	@Tag("valid")
	void findProductsWithSpecialCharactersInSearchString() {
		// Arrange
		productRepository.save(new Product("USB-C Cable", "USB-C cable description", new BigDecimal("14.99"), 100));

		// Act
		List<Product> result = productRepository.findByNameContaining("-C");

		// Assert
		assertEquals(1, result.size());
		assertEquals("USB-C Cable", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsWithWhitespaceInSearchString() {
		// Arrange
		productRepository.save(new Product("Gaming Mouse", "Gaming mouse description", new BigDecimal("49.99"), 10));

		// Act
		List<Product> result = productRepository.findByNameContaining("ing M");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Gaming Mouse", result.get(0).getName());
	}

	@Test
	@Tag("integration")
	void findProductsAfterAddingNewProduct() {
		// Arrange
		productRepository
			.save(new Product("Wireless Laptop Stand", "Laptop stand description", new BigDecimal("59.99"), 20));

		// Act
		List<Product> result = productRepository.findByNameContaining("Laptop");

		// Assert
		assertEquals(2, result.size());
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Laptop")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Wireless Laptop Stand")));
	}

	@Test
	@Tag("integration")
	void findProductsAfterDeletingProduct() {
		// Arrange
		List<Product> laptopProducts = productRepository.findByNameContaining("Laptop");
		assertFalse(laptopProducts.isEmpty());
		Long laptopId = laptopProducts.get(0).getId();
		productRepository.deleteById(laptopId);

		// Act
		List<Product> result = productRepository.findByNameContaining("Laptop");

		// Assert
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("valid")
	void findProductsWithNumericCharactersInSearchString() {
		// Arrange
		productRepository.save(new Product("USB 3.0 Hub", "USB hub description", new BigDecimal("24.99"), 35));

		// Act
		List<Product> result = productRepository.findByNameContaining("3.0");

		// Assert
		assertEquals(1, result.size());
		assertEquals("USB 3.0 Hub", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsWithSearchStringAtBeginningOfName() {
		// Arrange - repository is initialized with sample data including "Keyboard"

		// Act
		List<Product> result = productRepository.findByNameContaining("Key");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Keyboard", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findProductsWithSearchStringAtEndOfName() {
		// Arrange - repository is initialized with sample data including "Headphones"

		// Act
		List<Product> result = productRepository.findByNameContaining("phones");

		// Assert
		assertEquals(1, result.size());
		assertEquals("Headphones", result.get(0).getName());
	}

	@Test
	@Tag("boundary")
	void findProductsInEmptyRepository() {
		// Arrange - delete all pre-initialized products
		for (long i = 1; i <= 5; i++) {
			productRepository.deleteById(i);
		}
		assertEquals(0, productRepository.count());

		// Act
		List<Product> result = productRepository.findByNameContaining("Product");

		// Assert
		assertTrue(result.isEmpty());
		assertNotNull(result);
	}

}