
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findAll_cc65123f8c
ROOST_METHOD_SIG_HASH=findAll_39e53ccb66

Scenario 1: Retrieve All Users From Repository With Pre-populated Data

Details:
  TestName: findAllReturnsPrePopulatedUsers
  Description: Verify that the findAll method returns all users that were pre-populated during repository initialization. The repository constructor adds three sample users (Alice, Bob, and Charlie), so findAll should return a list containing exactly these three users.

Execution:
  Arrange: Create a new instance of UserRepository, which automatically initializes with three sample users.
  Act: Invoke the findAll() method on the repository instance.
  Assert: Verify that the returned list has a size of 3 and contains users with the expected names and emails.

Validation:
  The assertion verifies that the repository correctly returns all stored users after initialization. This is significant because it confirms the constructor properly populates the repository and findAll accurately retrieves all entries from the underlying ConcurrentHashMap.

---

Scenario 2: Verify findAll Returns A New ArrayList Instance

Details:
  TestName: findAllReturnsNewArrayListInstance
  Description: Verify that findAll returns a new ArrayList instance rather than a direct reference to the internal collection. This ensures that modifications to the returned list do not affect the internal state of the repository.

Execution:
  Arrange: Create a new instance of UserRepository.
  Act: Invoke findAll() twice and store both results. Modify the first returned list by clearing it.
  Assert: Verify that the second list still contains all users and the repository's count remains unchanged.

Validation:
  This assertion confirms defensive copying is implemented correctly. Returning a new ArrayList protects the internal ConcurrentHashMap from external modifications, which is crucial for maintaining data integrity in a concurrent environment.

---

Scenario 3: Retrieve Users After Adding A New User

Details:
  TestName: findAllIncludesNewlySavedUser
  Description: Verify that findAll returns all users including any newly saved user after the repository initialization.

Execution:
  Arrange: Create a new UserRepository instance and save a new User with name "David Wilson", email "david@example.com", and role "USER".
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list has a size of 4 and contains the newly added user.

Validation:
  This test validates that the findAll method dynamically reflects changes to the repository. It ensures that the save operation correctly adds users to the internal map and findAll retrieves the updated collection.

---

Scenario 4: Retrieve Users After Deleting A User

Details:
  TestName: findAllExcludesDeletedUser
  Description: Verify that findAll does not include users that have been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Use findAll to get the initial list and retrieve the ID of the first user. Delete that user using deleteById.
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list has a size of 2 and does not contain the deleted user.

Validation:
  This test confirms that findAll accurately reflects the current state of the repository after deletion operations. It is important for ensuring data consistency when users are removed from the system.

---

Scenario 5: Verify findAll Returns Empty List When All Users Are Deleted

Details:
  TestName: findAllReturnsEmptyListWhenNoUsers
  Description: Verify that findAll returns an empty list when all users have been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Retrieve all users using findAll and delete each user by their ID using deleteById.
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list is empty (size equals 0) and is not null.

Validation:
  This test validates the edge case where the repository contains no users. It ensures that findAll handles an empty ConcurrentHashMap gracefully by returning an empty ArrayList rather than null, which prevents NullPointerException in calling code.

---

Scenario 6: Verify findAll Returns Users In Collection Order

Details:
  TestName: findAllReturnsUsersFromMapValues
  Description: Verify that findAll returns users based on the values stored in the ConcurrentHashMap. The order may not be guaranteed due to the nature of ConcurrentHashMap.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Invoke findAll() and collect all user emails from the returned list.
  Assert: Verify that the returned list contains users with emails "alice@example.com", "bob@example.com", and "charlie@example.com" regardless of order.

Validation:
  This test confirms that all expected users are present in the returned list. Since ConcurrentHashMap does not guarantee iteration order, the test should verify presence rather than specific ordering, which reflects real-world usage patterns.

---

Scenario 7: Verify Multiple Consecutive findAll Calls Return Consistent Data

Details:
  TestName: findAllReturnsConsistentDataOnMultipleCalls
  Description: Verify that multiple consecutive calls to findAll return lists with the same content when no modifications are made between calls.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Invoke findAll() three times consecutively and store each result.
  Assert: Verify that all three lists have the same size and contain the same user data.

Validation:
  This test ensures the stability and consistency of the findAll method. It validates that repeated reads without intervening writes produce identical results, which is essential for predictable application behavior.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryFindAllTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void findAllReturnsPrePopulatedUsers() {
		// Arrange - repository is already initialized with 3 users in constructor
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(3, users.size());

		Set<String> emails = users.stream().map(User::getEmail).collect(Collectors.toSet());

		assertTrue(emails.contains("alice@example.com"));
		assertTrue(emails.contains("bob@example.com"));
		assertTrue(emails.contains("charlie@example.com"));
	}

	@Test
	@Tag("valid")
	void findAllReturnsNewArrayListInstance() {
		// Arrange - repository is already initialized
		// Act
		List<User> firstList = userRepository.findAll();
		List<User> secondList = userRepository.findAll();

		// Modify the first list
		firstList.clear();
		// Assert
		assertEquals(0, firstList.size());
		assertEquals(3, secondList.size());
		assertEquals(3, userRepository.count());
	}

	@Test
	@Tag("valid")
	void findAllIncludesNewlySavedUser() {
		// Arrange
		User newUser = new User("David Wilson", "david@example.com", "USER");
		userRepository.save(newUser);
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(4, users.size());

		boolean containsDavid = users.stream().anyMatch(user -> "david@example.com".equals(user.getEmail()));
		assertTrue(containsDavid);
	}

	@Test
	@Tag("valid")
	void findAllExcludesDeletedUser() {
		// Arrange
		List<User> initialUsers = userRepository.findAll();
		Long userIdToDelete = initialUsers.get(0).getId();
		String deletedEmail = initialUsers.get(0).getEmail();
		userRepository.deleteById(userIdToDelete);
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(2, users.size());

		boolean containsDeletedUser = users.stream().anyMatch(user -> deletedEmail.equals(user.getEmail()));
		assertFalse(containsDeletedUser);
	}

	@Test
	@Tag("boundary")
	void findAllReturnsEmptyListWhenNoUsers() {
		// Arrange
		List<User> allUsers = userRepository.findAll();
		for (User user : allUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(0, users.size());
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("valid")
	void findAllReturnsUsersFromMapValues() {
		// Arrange - repository is already initialized
		// Act
		List<User> users = userRepository.findAll();
		Set<String> emails = users.stream().map(User::getEmail).collect(Collectors.toSet());
		// Assert
		assertNotNull(users);
		assertEquals(3, emails.size());
		assertTrue(emails.contains("alice@example.com"));
		assertTrue(emails.contains("bob@example.com"));
		assertTrue(emails.contains("charlie@example.com"));
	}

	@Test
	@Tag("valid")
	void findAllReturnsConsistentDataOnMultipleCalls() {
		// Arrange - repository is already initialized
		// Act
		List<User> firstCall = userRepository.findAll();
		List<User> secondCall = userRepository.findAll();
		List<User> thirdCall = userRepository.findAll();
		// Assert
		assertEquals(firstCall.size(), secondCall.size());
		assertEquals(secondCall.size(), thirdCall.size());

		Set<String> firstEmails = firstCall.stream().map(User::getEmail).collect(Collectors.toSet());
		Set<String> secondEmails = secondCall.stream().map(User::getEmail).collect(Collectors.toSet());
		Set<String> thirdEmails = thirdCall.stream().map(User::getEmail).collect(Collectors.toSet());

		assertEquals(firstEmails, secondEmails);
		assertEquals(secondEmails, thirdEmails);
	}

}