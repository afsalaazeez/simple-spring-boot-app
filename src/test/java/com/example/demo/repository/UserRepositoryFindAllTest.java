
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findAll_cc65123f8c
ROOST_METHOD_SIG_HASH=findAll_39e53ccb66

Scenario 1: Retrieve All Users When Repository Contains Initial Sample Data

Details:
  TestName: findAllReturnsInitialSampleUsers
  Description: Verify that the findAll method returns all users that were initialized in the repository constructor. The repository is pre-populated with three sample users (Alice, Bob, and Charlie) upon instantiation.

Execution:
  Arrange: Create a new instance of UserRepository, which automatically initializes with three sample users.
  Act: Invoke the findAll() method on the repository instance.
  Assert: Verify that the returned list contains exactly 3 users.

Validation:
  The assertion confirms that the repository correctly returns all pre-populated users. This test is significant because it validates the default initialization behavior of the repository and ensures the findAll method properly retrieves all stored users from the ConcurrentHashMap.

---

Scenario 2: Verify findAll Returns New ArrayList Instance (Defensive Copy)

Details:
  TestName: findAllReturnsDefensiveCopyOfUsersList
  Description: Verify that the findAll method returns a new ArrayList instance rather than a direct reference to the internal collection, ensuring modifications to the returned list do not affect the repository's internal state.

Execution:
  Arrange: Create a new instance of UserRepository with its default sample data.
  Act: Call findAll() to get the list, then clear the returned list.
  Assert: Call findAll() again and verify the list still contains the original 3 users.

Validation:
  This assertion verifies that the repository implements a defensive copy pattern. Modifying the returned list should not impact the internal ConcurrentHashMap. This is crucial for maintaining data integrity and preventing unintended side effects from external code manipulating the returned collection.

---

Scenario 3: Retrieve All Users After Adding New User

Details:
  TestName: findAllIncludesNewlySavedUser
  Description: Verify that the findAll method returns all users including any newly added user after the repository was instantiated.

Execution:
  Arrange: Create a new UserRepository instance and save a new User with name "David Wilson", email "david@example.com", and role "USER".
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list contains exactly 4 users.

Validation:
  This assertion confirms that findAll correctly reflects the current state of the repository after modifications. It validates that the save operation properly adds users to the internal map and that findAll retrieves all entries including newly added ones.

---

Scenario 4: Retrieve All Users After Deleting A User

Details:
  TestName: findAllExcludesDeletedUser
  Description: Verify that the findAll method does not include users that have been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Use findAll() to get a user's ID, then delete that user using deleteById().
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list contains exactly 2 users.

Validation:
  This assertion ensures that findAll accurately reflects the repository state after deletion operations. It validates the consistency between delete operations and retrieval operations, which is essential for maintaining data accuracy in the application.

---

Scenario 5: Verify findAll Returns Empty List When All Users Are Deleted

Details:
  TestName: findAllReturnsEmptyListWhenNoUsersExist
  Description: Verify that the findAll method returns an empty list when all users have been removed from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Retrieve all users using findAll(), then delete each user by their ID using deleteById().
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list is empty (size equals 0) and is not null.

Validation:
  This assertion confirms that findAll handles the edge case of an empty repository gracefully by returning an empty ArrayList rather than null. This is important for preventing NullPointerExceptions in client code and follows best practices for collection return types.

---

Scenario 6: Verify findAll Returns Users With Correct Data Integrity

Details:
  TestName: findAllReturnsUsersWithCorrectAttributes
  Description: Verify that the users returned by findAll contain the correct attribute values (name, email, role) as they were stored in the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke the findAll() method and examine the returned users.
  Assert: Verify that the returned list contains users with emails "alice@example.com", "bob@example.com", and "charlie@example.com".

Validation:
  This assertion validates that findAll returns User objects with their data intact and unmodified. It ensures that the repository correctly stores and retrieves user information, which is fundamental for the application's data layer functionality.

---

Scenario 7: Verify findAll Is Thread-Safe With Concurrent Modifications

Details:
  TestName: findAllHandlesConcurrentAccess
  Description: Verify that the findAll method operates correctly when called concurrently with other operations, leveraging the thread-safe ConcurrentHashMap backing store.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Invoke findAll() multiple times in succession.
  Assert: Verify that each call returns a consistent list with the expected number of users and no exceptions are thrown.

Validation:
  This assertion confirms that findAll operates safely in a concurrent environment. Since the repository uses ConcurrentHashMap, the findAll method should be able to create snapshots of the current state without causing ConcurrentModificationException or data corruption.

---

Scenario 8: Verify findAll After Updating Existing User

Details:
  TestName: findAllReflectsUpdatedUserData
  Description: Verify that the findAll method returns users with updated information after a user has been modified and saved back to the repository.

Execution:
  Arrange: Create a new UserRepository instance. Retrieve a user using findById(), modify the user's attributes, and save the user back using save().
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list still contains 3 users (no duplicates created) and the modified user reflects the updated data.

Validation:
  This assertion ensures that findAll correctly returns updated user data after modifications. It validates that the save method properly updates existing entries rather than creating duplicates, maintaining data consistency in the repository.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryFindAllTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void findAllReturnsInitialSampleUsers() {
		// Arrange - repository is already initialized with 3 sample users in constructor
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(3, users.size());
	}

	@Test
	@Tag("valid")
	void findAllReturnsDefensiveCopyOfUsersList() {
		// Arrange - repository is already initialized with sample data
		// Act
		List<User> firstList = userRepository.findAll();
		firstList.clear();
		List<User> secondList = userRepository.findAll();
		// Assert
		assertNotNull(secondList);
		assertEquals(3, secondList.size());
	}

	@Test
	@Tag("valid")
	void findAllIncludesNewlySavedUser() {
		// Arrange
		User newUser = new User("David Wilson", "david@example.com", "USER");
		userRepository.save(newUser);
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(4, users.size());
	}

	@Test
	@Tag("valid")
	void findAllExcludesDeletedUser() {
		// Arrange
		List<User> initialUsers = userRepository.findAll();
		Long userIdToDelete = initialUsers.get(0).getId();
		userRepository.deleteById(userIdToDelete);
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(2, users.size());
	}

	@Test
	@Tag("boundary")
	void findAllReturnsEmptyListWhenNoUsersExist() {
		// Arrange
		List<User> allUsers = userRepository.findAll();
		for (User user : allUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(0, users.size());
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("valid")
	void findAllReturnsUsersWithCorrectAttributes() {
		// Arrange - repository is already initialized with sample data
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(3, users.size());
		List<String> emails = users.stream().map(User::getEmail).toList();
		assertTrue(emails.contains("alice@example.com"));
		assertTrue(emails.contains("bob@example.com"));
		assertTrue(emails.contains("charlie@example.com"));
	}

	@Test
	@Tag("integration")
	void findAllHandlesConcurrentAccess() {
		// Arrange - repository is already initialized
		// Act & Assert
		assertDoesNotThrow(() -> {
			List<User> firstCall = userRepository.findAll();
			List<User> secondCall = userRepository.findAll();
			List<User> thirdCall = userRepository.findAll();
			assertNotNull(firstCall);
			assertNotNull(secondCall);
			assertNotNull(thirdCall);
			assertEquals(3, firstCall.size());
			assertEquals(3, secondCall.size());
			assertEquals(3, thirdCall.size());
		});
	}

	@Test
	@Tag("valid")
	void findAllReflectsUpdatedUserData() {
		// Arrange
		List<User> initialUsers = userRepository.findAll();
		User userToUpdate = initialUsers.get(0);
		Long userId = userToUpdate.getId();

		userToUpdate.setName("Updated Name");
		userToUpdate.setEmail("updated@example.com");
		userRepository.save(userToUpdate);
		// Act
		List<User> users = userRepository.findAll();
		// Assert
		assertNotNull(users);
		assertEquals(3, users.size());
		Optional<User> updatedUser = users.stream().filter(u -> u.getId().equals(userId)).findFirst();
		assertTrue(updatedUser.isPresent());
		assertEquals("Updated Name", updatedUser.get().getName());
		assertEquals("updated@example.com", updatedUser.get().getEmail());
	}

}