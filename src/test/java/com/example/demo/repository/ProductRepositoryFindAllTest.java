
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findAll_e3226f7b62
ROOST_METHOD_SIG_HASH=findAll_a2bf6614ea

Scenario 1: Retrieve All Products From Repository With Initial Sample Data

Details:
  TestName: findAllReturnsInitialSampleProducts
  Description: Verify that the findAll method returns all products that were initialized in the repository constructor. The repository is pre-populated with 5 sample products (Laptop, Mouse, Keyboard, Monitor, Headphones) upon instantiation.

Execution:
  Arrange: Create a new instance of ProductRepository, which automatically initializes with 5 sample products.
  Act: Invoke the findAll() method on the repository instance.
  Assert: Verify that the returned list contains exactly 5 products.

Validation:
  The assertion confirms that the repository correctly returns all pre-populated products. This test is significant because it validates the basic retrieval functionality and ensures the constructor properly initializes the sample data, which is essential for the application's initial state.

---

Scenario 2: Verify findAll Returns A New ArrayList Instance

Details:
  TestName: findAllReturnsNewArrayListNotBackedByInternalMap
  Description: Verify that the findAll method returns a new ArrayList that is not backed by the internal ConcurrentHashMap. Modifications to the returned list should not affect the internal storage.

Execution:
  Arrange: Create a new instance of ProductRepository.
  Act: Invoke findAll() and attempt to clear the returned list.
  Assert: Call findAll() again and verify the original products are still present in the repository.

Validation:
  This assertion ensures that the method creates a defensive copy of the products collection. This is critical for maintaining data integrity and preventing external code from accidentally or maliciously modifying the repository's internal state.

---

Scenario 3: Retrieve All Products After Adding New Product

Details:
  TestName: findAllIncludesNewlySavedProduct
  Description: Verify that the findAll method returns all products including any newly added product after the initial sample data.

Execution:
  Arrange: Create a new ProductRepository instance and save a new Product with name "Tablet", description "10-inch tablet", price BigDecimal("499.99"), and quantity 10.
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list contains 6 products (5 initial + 1 new).

Validation:
  This test validates that the findAll method dynamically reflects changes to the repository. It ensures that newly saved products are properly included in subsequent retrieval operations, which is essential for CRUD functionality.

---

Scenario 4: Retrieve All Products After Deleting A Product

Details:
  TestName: findAllExcludesDeletedProduct
  Description: Verify that the findAll method does not return products that have been deleted from the repository.

Execution:
  Arrange: Create a new ProductRepository instance and delete a product by its ID (e.g., ID 1L).
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list contains 4 products and none of them has ID 1L.

Validation:
  This test confirms that deleted products are properly removed from the collection returned by findAll. It validates the consistency between delete operations and retrieval operations, ensuring data integrity.

---

Scenario 5: Verify findAll Returns Products With Correct Data Types

Details:
  TestName: findAllReturnsListOfProductType
  Description: Verify that the findAll method returns a List containing elements of type Product, ensuring type safety.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Invoke the findAll() method and store the result.
  Assert: Verify that the returned object is an instance of List and each element is an instance of Product.

Validation:
  This test ensures type safety of the returned collection. It validates that the method signature is correctly implemented and that the generic type is properly maintained, which is important for compile-time and runtime type checking.

---

Scenario 6: Retrieve All Products After Multiple Save Operations

Details:
  TestName: findAllReflectsMultipleSaveOperations
  Description: Verify that findAll correctly returns all products after multiple save operations have been performed on the repository.

Execution:
  Arrange: Create a new ProductRepository instance and save three new products with different names and prices.
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list contains 8 products (5 initial + 3 new).

Validation:
  This test validates that the repository correctly accumulates products across multiple save operations. It ensures the ConcurrentHashMap properly stores all entries and findAll retrieves them all.

---

Scenario 7: Verify findAll Returns Products After Update Operation

Details:
  TestName: findAllReturnsUpdatedProductData
  Description: Verify that when a product is updated (saved with existing ID), findAll returns the updated product data rather than the original.

Execution:
  Arrange: Create a new ProductRepository instance, retrieve a product by ID, modify its properties, and save it back.
  Act: Invoke the findAll() method.
  Assert: Verify that the list still contains 5 products and the modified product reflects the updated values.

Validation:
  This test ensures that update operations are properly reflected in findAll results. It validates that the save method correctly overwrites existing entries in the ConcurrentHashMap when the product has an existing ID.

---

Scenario 8: Verify findAll Is Thread-Safe With Concurrent Access

Details:
  TestName: findAllHandlesConcurrentAccess
  Description: Verify that findAll can be safely called while other threads are modifying the repository, leveraging the ConcurrentHashMap's thread-safety.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Invoke findAll() method.
  Assert: Verify that no ConcurrentModificationException is thrown and a valid list is returned.

Validation:
  This test validates the thread-safety aspect of the repository implementation. Since the internal storage uses ConcurrentHashMap, findAll should safely create a snapshot of the current values without throwing exceptions during concurrent modifications.

---

Scenario 9: Verify findAll Returns Empty List After All Products Deleted

Details:
  TestName: findAllReturnsEmptyListWhenAllProductsDeleted
  Description: Verify that findAll returns an empty list when all products have been deleted from the repository.

Execution:
  Arrange: Create a new ProductRepository instance and delete all 5 initial products by their IDs (1L through 5L).
  Act: Invoke the findAll() method.
  Assert: Verify that the returned list is empty (size equals 0) and is not null.

Validation:
  This test validates the edge case where the repository becomes empty. It ensures that findAll gracefully handles an empty state by returning an empty ArrayList rather than null, which prevents NullPointerException in calling code.

---

Scenario 10: Verify findAll Returns Consistent Results On Multiple Calls

Details:
  TestName: findAllReturnsConsistentResultsOnMultipleCalls
  Description: Verify that calling findAll multiple times without any modifications returns lists with the same content.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Invoke findAll() twice and store both results.
  Assert: Verify that both lists have the same size and contain products with matching IDs.

Validation:
  This test ensures the idempotent nature of the findAll method. When no modifications occur between calls, the results should be consistent, which is important for predictable application behavior.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryFindAllTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void findAllReturnsInitialSampleProducts() {
		// Arrange - repository is already initialized with 5 sample products in
		// constructor
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertEquals(5, products.size());
	}

	@Test
	@Tag("valid")
	void findAllReturnsNewArrayListNotBackedByInternalMap() {
		// Arrange
		List<Product> firstList = productRepository.findAll();
		// Act
		firstList.clear();
		// Assert
		List<Product> secondList = productRepository.findAll();
		assertNotNull(secondList);
		assertEquals(5, secondList.size());
	}

	@Test
	@Tag("valid")
	void findAllIncludesNewlySavedProduct() {
		// Arrange
		Product newProduct = new Product("Tablet", "10-inch tablet", new BigDecimal("499.99"), 10);
		productRepository.save(newProduct);
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertEquals(6, products.size());
		assertTrue(products.stream().anyMatch(p -> "Tablet".equals(p.getName())));
	}

	@Test
	@Tag("valid")
	void findAllExcludesDeletedProduct() {
		// Arrange
		productRepository.deleteById(1L);
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertEquals(4, products.size());
		assertTrue(products.stream().noneMatch(p -> p.getId().equals(1L)));
	}

	@Test
	@Tag("valid")
	void findAllReturnsListOfProductType() {
		// Arrange - repository already initialized
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertInstanceOf(List.class, products);
		for (Object item : products) {
			assertInstanceOf(Product.class, item);
		}
	}

	@Test
	@Tag("valid")
	void findAllReflectsMultipleSaveOperations() {
		// Arrange
		productRepository.save(new Product("Tablet", "10-inch tablet", new BigDecimal("499.99"), 10));
		productRepository.save(new Product("Webcam", "HD webcam", new BigDecimal("79.99"), 40));
		productRepository.save(new Product("USB Hub", "7-port USB hub", new BigDecimal("39.99"), 60));
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertEquals(8, products.size());
	}

	@Test
	@Tag("valid")
	void findAllReturnsUpdatedProductData() {
		// Arrange
		Product existingProduct = productRepository.findById(1L).orElseThrow();
		String updatedName = "Updated Laptop";
		existingProduct.setName(updatedName);
		productRepository.save(existingProduct);
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertEquals(5, products.size());
		assertTrue(products.stream().anyMatch(p -> updatedName.equals(p.getName())));
	}

	@Test
	@Tag("integration")
	void findAllHandlesConcurrentAccess() {
		// Arrange - repository already initialized
		// Act & Assert
		assertDoesNotThrow(() -> {
			List<Product> products = productRepository.findAll();
			assertNotNull(products);
			assertTrue(products.size() >= 0);
		});
	}

	@Test
	@Tag("boundary")
	void findAllReturnsEmptyListWhenAllProductsDeleted() {
		// Arrange
		for (long id = 1L; id <= 5L; id++) {
			productRepository.deleteById(id);
		}
		// Act
		List<Product> products = productRepository.findAll();
		// Assert
		assertNotNull(products);
		assertTrue(products.isEmpty());
		assertEquals(0, products.size());
	}

	@Test
	@Tag("valid")
	void findAllReturnsConsistentResultsOnMultipleCalls() {
		// Arrange - repository already initialized
		// Act
		List<Product> firstCall = productRepository.findAll();
		List<Product> secondCall = productRepository.findAll();
		// Assert
		assertNotNull(firstCall);
		assertNotNull(secondCall);
		assertEquals(firstCall.size(), secondCall.size());
		Set<Long> firstIds = firstCall.stream().map(Product::getId).collect(Collectors.toSet());
		Set<Long> secondIds = secondCall.stream().map(Product::getId).collect(Collectors.toSet());
		assertEquals(firstIds, secondIds);
	}

}