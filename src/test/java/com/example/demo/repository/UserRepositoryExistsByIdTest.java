
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=existsById_28aaa34d3a
ROOST_METHOD_SIG_HASH=existsById_83b9bf1592

Scenario 1: Check if user exists with a valid existing ID

Details:
  TestName: existsByIdReturnsTrueForExistingUser
  Description: This test verifies that the existsById method returns true when checking for a user ID that exists in the repository. The repository is pre-populated with sample data during construction, so existing IDs should be found.

Execution:
  Arrange: Create a new UserRepository instance which automatically initializes with sample users (IDs 1, 2, and 3).
  Act: Call existsById with ID 1L (which corresponds to the first pre-populated user "Alice Johnson").
  Assert: Assert that the returned value is true.

Validation:
  The assertion verifies that the method correctly identifies an existing user in the ConcurrentHashMap. This is important for business logic that needs to check user existence before performing operations like updates or preventing duplicate entries.

---

Scenario 2: Check if user exists with a non-existing ID

Details:
  TestName: existsByIdReturnsFalseForNonExistingUser
  Description: This test verifies that the existsById method returns false when checking for a user ID that does not exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance with the default sample data.
  Act: Call existsById with ID 999L (an ID that was never assigned to any user).
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method correctly returns false for non-existing IDs. This is crucial for validation logic that needs to determine whether a user exists before attempting operations that require an existing user.

---

Scenario 3: Check if user exists with null ID

Details:
  TestName: existsByIdReturnsFalseForNullId
  Description: This test verifies the behavior of existsById when a null value is passed as the ID parameter. ConcurrentHashMap's containsKey method throws NullPointerException for null keys.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Call existsById with null as the parameter.
  Assert: Assert that a NullPointerException is thrown.

Validation:
  The assertion verifies that the method propagates the NullPointerException from ConcurrentHashMap.containsKey() when null is passed. This behavior is important to document as it affects how calling code should handle null ID values.

---

Scenario 4: Check if user exists with ID zero

Details:
  TestName: existsByIdReturnsFalseForZeroId
  Description: This test verifies that existsById returns false when checking for ID 0L, which is never assigned by the AtomicLong idGenerator that starts at 1.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with ID 0L.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that zero is not a valid user ID in this repository implementation since the idGenerator starts at 1. This edge case is important for boundary testing.

---

Scenario 5: Check if user exists with negative ID

Details:
  TestName: existsByIdReturnsFalseForNegativeId
  Description: This test verifies that existsById returns false when checking for a negative ID value, which should never be assigned by the repository.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Call existsById with ID -1L.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that negative IDs are not found in the repository. This is an edge case that ensures the method handles invalid ID ranges gracefully.

---

Scenario 6: Check if user exists after saving a new user

Details:
  TestName: existsByIdReturnsTrueAfterSavingNewUser
  Description: This test verifies that existsById returns true for a newly saved user's ID, confirming the integration between save and existsById methods.

Execution:
  Arrange: Create a new UserRepository instance. Create a new User object with name "Test User", email "test@example.com", and role "USER". Save the user using the save method and capture the returned user with assigned ID.
  Act: Call existsById with the ID of the saved user.
  Assert: Assert that the returned value is true.

Validation:
  The assertion verifies that after saving a user, the existsById method correctly identifies the user as existing. This confirms proper integration between the save operation and existence checking.

---

Scenario 7: Check if user exists after deletion

Details:
  TestName: existsByIdReturnsFalseAfterUserDeletion
  Description: This test verifies that existsById returns false for a user ID after that user has been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data. Delete the user with ID 1L using deleteById method.
  Act: Call existsById with ID 1L.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that once a user is deleted, existsById correctly reports that the user no longer exists. This is critical for maintaining data consistency and ensuring deleted users are properly removed.

---

Scenario 8: Check if user exists with maximum Long value

Details:
  TestName: existsByIdReturnsFalseForMaxLongValue
  Description: This test verifies that existsById handles the maximum Long value (Long.MAX_VALUE) correctly, returning false since such an ID would not be assigned under normal circumstances.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Call existsById with Long.MAX_VALUE.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method handles extreme boundary values correctly. This edge case ensures robustness when dealing with potentially malicious or erroneous input values.

---

Scenario 9: Check existence of all pre-populated users

Details:
  TestName: existsByIdReturnsTrueForAllPrePopulatedUsers
  Description: This test verifies that existsById returns true for all three pre-populated users (IDs 1, 2, and 3) that are created during repository initialization.

Execution:
  Arrange: Create a new UserRepository instance which initializes with three sample users.
  Act: Call existsById for IDs 1L, 2L, and 3L.
  Assert: Assert that all three calls return true.

Validation:
  The assertion verifies that all pre-populated users are correctly stored and can be found by their IDs. This confirms the constructor's initialization logic works correctly with the existsById method.

---

Scenario 10: Check if user exists with ID just beyond pre-populated range

Details:
  TestName: existsByIdReturnsFalseForIdBeyondPrePopulatedRange
  Description: This test verifies that existsById returns false for ID 4L, which is the next ID that would be assigned but hasn't been used yet after the three pre-populated users.

Execution:
  Arrange: Create a new UserRepository instance with default sample data (IDs 1, 2, 3 are used).
  Act: Call existsById with ID 4L.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method correctly distinguishes between assigned and unassigned IDs at the boundary of the current ID sequence. This is important for understanding the repository's ID assignment behavior.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryExistsByIdTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForExistingUser() {
		// Arrange - repository is pre-populated with users (IDs 1, 2, 3)

		// Act
		boolean result = userRepository.existsById(1L);

		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNonExistingUser() {
		// Arrange - repository is pre-populated with users (IDs 1, 2, 3)

		// Act
		boolean result = userRepository.existsById(999L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNullId() {
		// Arrange - repository is pre-populated

		// Act & Assert
		assertThrows(NullPointerException.class, () -> userRepository.existsById(null));
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForZeroId() {
		// Arrange - repository is pre-populated with users (IDs 1, 2, 3)

		// Act
		boolean result = userRepository.existsById(0L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForNegativeId() {
		// Arrange - repository is pre-populated

		// Act
		boolean result = userRepository.existsById(-1L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsTrueAfterSavingNewUser() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		User savedUser = userRepository.save(newUser);

		// Act
		boolean result = userRepository.existsById(savedUser.getId());

		// Assert
		assertTrue(result);
		assertNotNull(savedUser.getId());
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterUserDeletion() {
		// Arrange
		assertTrue(userRepository.existsById(1L)); // Verify user exists before deletion
		userRepository.deleteById(1L);

		// Act
		boolean result = userRepository.existsById(1L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForMaxLongValue() {
		// Arrange - repository is pre-populated

		// Act
		boolean result = userRepository.existsById(Long.MAX_VALUE);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForAllPrePopulatedUsers() {
		// Arrange - repository is pre-populated with users (IDs 1, 2, 3)

		// Act
		boolean existsUser1 = userRepository.existsById(1L);
		boolean existsUser2 = userRepository.existsById(2L);
		boolean existsUser3 = userRepository.existsById(3L);

		// Assert
		assertTrue(existsUser1);
		assertTrue(existsUser2);
		assertTrue(existsUser3);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForIdBeyondPrePopulatedRange() {
		// Arrange - repository is pre-populated with users (IDs 1, 2, 3)

		// Act
		boolean result = userRepository.existsById(4L);

		// Assert
		assertFalse(result);
	}

}