
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=existsById_28aaa34d3a
ROOST_METHOD_SIG_HASH=existsById_83b9bf1592

Scenario 1: Check if user exists with a valid existing ID

Details:
  TestName: existsByIdReturnsTrueForExistingUser
  Description: This test verifies that the existsById method returns true when checking for a user ID that exists in the repository. The repository is initialized with sample data, so existing IDs should be found.

Execution:
  Arrange: Create a new UserRepository instance which automatically initializes with sample users (IDs 1, 2, and 3).
  Act: Call existsById with ID 1L (which corresponds to the first sample user "Alice Johnson").
  Assert: Assert that the returned value is true.

Validation:
  The assertion verifies that the method correctly identifies an existing user in the ConcurrentHashMap. This is important for business logic that needs to verify user existence before performing operations like updates or deletions.

---

Scenario 2: Check if user exists with a non-existing ID

Details:
  TestName: existsByIdReturnsFalseForNonExistingUser
  Description: This test verifies that the existsById method returns false when checking for a user ID that does not exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with ID 999L (an ID that was never assigned).
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method correctly returns false for non-existing IDs. This is crucial for preventing operations on non-existent users and for validation logic in the application.

---

Scenario 3: Check if user exists with null ID

Details:
  TestName: existsByIdReturnsFalseForNullId
  Description: This test verifies the behavior of existsById when a null value is passed as the ID parameter. ConcurrentHashMap's containsKey method does not accept null keys and will throw NullPointerException.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Call existsById with null as the parameter.
  Assert: Assert that a NullPointerException is thrown.

Validation:
  This test validates the edge case behavior when null is passed. Since ConcurrentHashMap does not allow null keys, this test ensures the expected exception behavior is documented and handled appropriately by calling code.

---

Scenario 4: Check if user exists after saving a new user

Details:
  TestName: existsByIdReturnsTrueAfterSavingNewUser
  Description: This test verifies that existsById returns true for a newly saved user's ID, confirming that the save operation correctly adds the user to the repository.

Execution:
  Arrange: Create a new UserRepository instance and save a new User with name "Test User", email "test@example.com", and role "USER".
  Act: Retrieve the saved user's ID and call existsById with that ID.
  Assert: Assert that the returned value is true.

Validation:
  This test confirms the integration between save and existsById methods, ensuring that newly created users are properly stored and can be verified for existence.

---

Scenario 5: Check if user exists after deletion

Details:
  TestName: existsByIdReturnsFalseAfterDeletion
  Description: This test verifies that existsById returns false for a user ID after that user has been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance (which has sample users). Verify user with ID 1L exists, then delete that user using deleteById.
  Act: Call existsById with ID 1L after deletion.
  Assert: Assert that the returned value is false.

Validation:
  This test ensures that the repository correctly reflects the state after deletion operations. It validates that deleted users are no longer found by existsById, which is essential for maintaining data integrity.

---

Scenario 6: Check if user exists with zero ID

Details:
  TestName: existsByIdReturnsFalseForZeroId
  Description: This test verifies that existsById returns false when checking for ID 0L, which is not a valid user ID since the idGenerator starts at 1.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with ID 0L.
  Assert: Assert that the returned value is false.

Validation:
  This test covers the edge case of zero as an ID value. Since the AtomicLong idGenerator starts at 1, no user should ever have ID 0, and the method should correctly return false.

---

Scenario 7: Check if user exists with negative ID

Details:
  TestName: existsByIdReturnsFalseForNegativeId
  Description: This test verifies that existsById returns false when checking for a negative ID value, which should never be assigned to any user.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with ID -1L.
  Assert: Assert that the returned value is false.

Validation:
  This test validates the behavior with invalid negative IDs. Since the idGenerator only produces positive values, negative IDs should never exist, and the method should return false.

---

Scenario 8: Check if user exists with maximum Long value

Details:
  TestName: existsByIdReturnsFalseForMaxLongId
  Description: This test verifies that existsById correctly handles the maximum Long value (Long.MAX_VALUE) as an ID parameter.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with Long.MAX_VALUE.
  Assert: Assert that the returned value is false.

Validation:
  This test covers the boundary condition of the maximum possible Long value. It ensures the method handles extreme values without errors and returns the correct result.

---

Scenario 9: Check existence of all initially created sample users

Details:
  TestName: existsByIdReturnsTrueForAllSampleUsers
  Description: This test verifies that all three sample users created during repository initialization exist and can be found using existsById.

Execution:
  Arrange: Create a new UserRepository instance which initializes with three sample users.
  Act: Call existsById for IDs 1L, 2L, and 3L.
  Assert: Assert that all three calls return true.

Validation:
  This test confirms that the constructor properly initializes the repository with sample data and that all sample users are accessible via existsById. It validates the initial state of the repository.

---

Scenario 10: Check if user exists with ID just beyond sample data range

Details:
  TestName: existsByIdReturnsFalseForIdBeyondSampleRange
  Description: This test verifies that existsById returns false for ID 4L, which is the next ID that would be assigned but hasn't been used yet after the three sample users.

Execution:
  Arrange: Create a new UserRepository instance with default sample data (IDs 1, 2, 3 are used).
  Act: Call existsById with ID 4L.
  Assert: Assert that the returned value is false.

Validation:
  This test validates the boundary between existing and non-existing IDs. It confirms that the method correctly distinguishes between assigned and unassigned IDs at the edge of the current data range.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryExistsByIdTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForExistingUser() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(1L);
		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNonExistingUser() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(999L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNullId() {
		// Arrange - repository is initialized with sample users in constructor
		// Act & Assert
		assertThrows(NullPointerException.class, () -> userRepository.existsById(null));
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsTrueAfterSavingNewUser() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		User savedUser = userRepository.save(newUser);
		// Act
		boolean result = userRepository.existsById(savedUser.getId());
		// Assert
		assertTrue(result);
		assertNotNull(savedUser.getId());
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterDeletion() {
		// Arrange
		assertTrue(userRepository.existsById(1L)); // Verify user exists before deletion
		userRepository.deleteById(1L);
		// Act
		boolean result = userRepository.existsById(1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForZeroId() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(0L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForNegativeId() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(-1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForMaxLongId() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(Long.MAX_VALUE);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForAllSampleUsers() {
		// Arrange - repository is initialized with three sample users in constructor
		// Act & Assert
		assertTrue(userRepository.existsById(1L));
		assertTrue(userRepository.existsById(2L));
		assertTrue(userRepository.existsById(3L));
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForIdBeyondSampleRange() {
		// Arrange - repository is initialized with sample users (IDs 1, 2, 3)
		// Act
		boolean result = userRepository.existsById(4L);
		// Assert
		assertFalse(result);
	}

}