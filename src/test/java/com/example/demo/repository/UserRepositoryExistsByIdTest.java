
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=existsById_28aaa34d3a
ROOST_METHOD_SIG_HASH=existsById_83b9bf1592

Scenario 1: Check if an existing user ID returns true

Details:
  TestName: existsByIdReturnsTrueForExistingUser
  Description: This test verifies that the existsById method returns true when checking for a user ID that exists in the repository. The repository is initialized with sample data, so existing IDs should be found.

Execution:
  Arrange: Create a new UserRepository instance which automatically initializes with sample users (IDs 1, 2, and 3 are assigned during construction).
  Act: Call existsById with an ID that exists in the repository (e.g., 1L).
  Assert: Assert that the method returns true.

Validation:
  The assertion verifies that the method correctly identifies an existing user in the ConcurrentHashMap. This is important for business logic that needs to validate user existence before performing operations like updates or retrievals.

---

Scenario 2: Check if a non-existing user ID returns false

Details:
  TestName: existsByIdReturnsFalseForNonExistingUser
  Description: This test verifies that the existsById method returns false when checking for a user ID that does not exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with an ID that does not exist in the repository (e.g., 999L).
  Assert: Assert that the method returns false.

Validation:
  The assertion confirms that the method correctly identifies when a user ID is not present in the map. This is crucial for preventing operations on non-existent users and for proper error handling in the application.

---

Scenario 3: Check existsById with null ID parameter

Details:
  TestName: existsByIdWithNullIdReturnsFalse
  Description: This test verifies the behavior of existsById when a null value is passed as the ID parameter. ConcurrentHashMap's containsKey method throws NullPointerException for null keys.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Call existsById with null as the parameter.
  Assert: Assert that a NullPointerException is thrown.

Validation:
  This test validates the edge case behavior when null is passed. Since ConcurrentHashMap does not allow null keys, the method will throw a NullPointerException. Understanding this behavior is important for proper input validation in calling code.

---

Scenario 4: Check existsById after saving a new user

Details:
  TestName: existsByIdReturnsTrueAfterSavingNewUser
  Description: This test verifies that existsById returns true for a newly saved user's ID, confirming that the save operation correctly adds the user to the repository.

Execution:
  Arrange: Create a new UserRepository instance and save a new User with name, email, and role.
  Act: Retrieve the saved user's ID and call existsById with that ID.
  Assert: Assert that the method returns true.

Validation:
  This test confirms the integration between save and existsById methods. It ensures that after a user is saved, their existence can be verified, which is essential for confirming successful data persistence.

---

Scenario 5: Check existsById after deleting a user

Details:
  TestName: existsByIdReturnsFalseAfterDeletingUser
  Description: This test verifies that existsById returns false for a user ID after that user has been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data. Delete a user by calling deleteById with an existing ID (e.g., 1L).
  Act: Call existsById with the same ID that was deleted.
  Assert: Assert that the method returns false.

Validation:
  This test confirms the integration between deleteById and existsById methods. It ensures that after a user is deleted, they are no longer found in the repository, which is critical for maintaining data integrity.

---

Scenario 6: Check existsById with zero as ID

Details:
  TestName: existsByIdWithZeroIdReturnsFalse
  Description: This test verifies that existsById returns false when checking for ID value of 0, which is not a valid auto-generated ID since the idGenerator starts at 1.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with 0L as the parameter.
  Assert: Assert that the method returns false.

Validation:
  This test validates the boundary condition where ID is zero. Since the AtomicLong idGenerator starts at 1, zero should never be a valid user ID in normal operation, and the method should return false.

---

Scenario 7: Check existsById with negative ID

Details:
  TestName: existsByIdWithNegativeIdReturnsFalse
  Description: This test verifies that existsById returns false when checking for a negative ID value, which should never exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with a negative value (e.g., -1L).
  Assert: Assert that the method returns false.

Validation:
  This test validates the edge case of negative IDs. Since the idGenerator produces only positive values starting from 1, negative IDs should never exist, and the method should correctly return false.

---

Scenario 8: Check existsById with Long.MAX_VALUE

Details:
  TestName: existsByIdWithMaxLongValueReturnsFalse
  Description: This test verifies that existsById handles the maximum Long value correctly and returns false when such an ID does not exist.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Call existsById with Long.MAX_VALUE.
  Assert: Assert that the method returns false.

Validation:
  This test validates the boundary condition at the maximum Long value. It ensures the method handles extreme values without errors and correctly reports that such an ID does not exist.

---

Scenario 9: Check existsById for all initially created users

Details:
  TestName: existsByIdReturnsTrueForAllInitialUsers
  Description: This test verifies that existsById returns true for all three users that are created during repository initialization (IDs 1, 2, and 3).

Execution:
  Arrange: Create a new UserRepository instance which initializes with three sample users.
  Act: Call existsById for IDs 1L, 2L, and 3L.
  Assert: Assert that the method returns true for all three IDs.

Validation:
  This test confirms that the constructor properly initializes the repository with sample data and that all initial users can be found. This is important for verifying the repository's initial state.

---

Scenario 10: Check existsById after clearing all users via multiple deletes

Details:
  TestName: existsByIdReturnsFalseAfterAllUsersDeleted
  Description: This test verifies that existsById returns false for all IDs after all users have been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Delete all initial users by calling deleteById for IDs 1L, 2L, and 3L.
  Act: Call existsById for each of the deleted IDs.
  Assert: Assert that the method returns false for all three IDs.

Validation:
  This test confirms that after all users are removed, the repository correctly reports that no users exist. This validates the complete removal of data and proper state management.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryExistsByIdTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForExistingUser() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(1L);
		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNonExistingUser() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(999L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithNullIdReturnsFalse() {
		// Arrange - repository is initialized with sample users in constructor
		// Act & Assert
		assertThrows(NullPointerException.class, () -> userRepository.existsById(null));
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsTrueAfterSavingNewUser() {
		// Arrange
		User newUser = new User("Test User", "test@example.com", "USER");
		User savedUser = userRepository.save(newUser);
		// Act
		boolean result = userRepository.existsById(savedUser.getId());
		// Assert
		assertTrue(result);
		assertNotNull(savedUser.getId());
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterDeletingUser() {
		// Arrange
		assertTrue(userRepository.existsById(1L)); // Verify user exists before deletion
		userRepository.deleteById(1L);
		// Act
		boolean result = userRepository.existsById(1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithZeroIdReturnsFalse() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(0L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithNegativeIdReturnsFalse() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(-1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithMaxLongValueReturnsFalse() {
		// Arrange - repository is initialized with sample users in constructor
		// Act
		boolean result = userRepository.existsById(Long.MAX_VALUE);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForAllInitialUsers() {
		// Arrange - repository is initialized with three sample users in constructor
		// Act & Assert
		assertTrue(userRepository.existsById(1L));
		assertTrue(userRepository.existsById(2L));
		assertTrue(userRepository.existsById(3L));
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterAllUsersDeleted() {
		// Arrange
		userRepository.deleteById(1L);
		userRepository.deleteById(2L);
		userRepository.deleteById(3L);
		// Act & Assert
		assertFalse(userRepository.existsById(1L));
		assertFalse(userRepository.existsById(2L));
		assertFalse(userRepository.existsById(3L));
	}

}