
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findAllActiveUsers_193540cac3
ROOST_METHOD_SIG_HASH=findAllActiveUsers_31324daed4

Scenario 1: Find All Active Users When Both USER and ADMIN Roles Exist

Details:
  TestName: findAllActiveUsersReturnsUsersWithBothRoles
  Description: Verify that the method returns a list containing all users with both "USER" and "ADMIN" roles when both types of users exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance which automatically initializes with sample data containing users with both USER and ADMIN roles.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that the returned list is not empty and contains users with both "USER" and "ADMIN" roles.

Validation:
  The assertion verifies that the method correctly aggregates users from both role categories. This is significant because the method is designed to return all active users regardless of whether they are regular users or administrators, ensuring comprehensive user retrieval for operations that need to target all active participants.

---

Scenario 2: Find All Active Users Returns Empty List When No Users Exist

Details:
  TestName: findAllActiveUsersReturnsEmptyListWhenNoUsersExist
  Description: Verify that the method returns an empty list when the repository contains no users at all.

Execution:
  Arrange: Create a new UserRepository instance and clear all users by deleting each user using deleteById() method for all existing users.
  Act: Invoke the findAllActiveUsers() method on the empty repository.
  Assert: Verify that the returned list is empty with size equal to 0.

Validation:
  The assertion confirms that the method handles the edge case of an empty repository gracefully without throwing exceptions. This is important for application stability when the system is in an initial state or after all users have been removed.

---

Scenario 3: Find All Active Users When Only USER Role Exists

Details:
  TestName: findAllActiveUsersReturnsOnlyUsersWhenNoAdminsExist
  Description: Verify that the method returns only users with "USER" role when no users with "ADMIN" role exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance, then remove all ADMIN users by finding them and deleting them, leaving only USER role users.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that the returned list contains only users with "USER" role and no users with "ADMIN" role.

Validation:
  The assertion verifies that the method correctly handles partial data scenarios where only one role type exists. This ensures the method doesn't fail or return incorrect results when the ADMIN role query returns an empty result.

---

Scenario 4: Find All Active Users When Only ADMIN Role Exists

Details:
  TestName: findAllActiveUsersReturnsOnlyAdminsWhenNoUsersExist
  Description: Verify that the method returns only users with "ADMIN" role when no users with "USER" role exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance, then remove all USER role users by finding them and deleting them, leaving only ADMIN role users.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that the returned list contains only users with "ADMIN" role and no users with "USER" role.

Validation:
  The assertion confirms that the method handles scenarios where only administrators exist in the system. This is relevant for newly deployed systems or specialized environments where only administrative accounts have been created.

---

Scenario 5: Find All Active Users Excludes Users With Other Roles

Details:
  TestName: findAllActiveUsersExcludesNonUserAndNonAdminRoles
  Description: Verify that the method does not include users with roles other than "USER" or "ADMIN" in the returned list.

Execution:
  Arrange: Create a new UserRepository instance and add a user with a different role such as "GUEST" or "MODERATOR" using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that the returned list does not contain any users with roles other than "USER" or "ADMIN".

Validation:
  The assertion ensures that the method strictly filters for only the two specified roles. This is critical for security and access control, ensuring that only legitimate active user types are returned and not temporary or restricted account types.

---

Scenario 6: Find All Active Users Returns Correct Count

Details:
  TestName: findAllActiveUsersReturnsCorrectTotalCount
  Description: Verify that the method returns the correct total count of users combining both USER and ADMIN roles.

Execution:
  Arrange: Create a new UserRepository instance with the default sample data (1 ADMIN and 2 USERs).
  Act: Invoke the findAllActiveUsers() method and count the returned users.
  Assert: Verify that the returned list size equals 3 (the sum of 1 ADMIN and 2 USERs from default initialization).

Validation:
  The assertion validates that the addAll operations correctly combine both role lists without duplicating or missing any users. This is important for accurate user counting in administrative dashboards and reporting features.

---

Scenario 7: Find All Active Users After Adding New Users

Details:
  TestName: findAllActiveUsersIncludesNewlyAddedUsers
  Description: Verify that the method includes newly added users with USER or ADMIN roles in the returned list.

Execution:
  Arrange: Create a new UserRepository instance and add additional users with USER and ADMIN roles using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that the returned list includes both the original sample users and the newly added users.

Validation:
  The assertion confirms that the method dynamically retrieves current data from the repository rather than using cached results. This is essential for real-time user management where new users should be immediately visible after registration.

---

Scenario 8: Find All Active Users Is Case Insensitive For Roles

Details:
  TestName: findAllActiveUsersHandlesCaseInsensitiveRoles
  Description: Verify that the method correctly finds users regardless of the case used for role names (e.g., "user", "User", "USER").

Execution:
  Arrange: Create a new UserRepository instance and add users with role names in different cases such as "user", "User", "admin", "Admin" using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository.
  Assert: Verify that all users with USER and ADMIN roles are returned regardless of the case used in their role assignment.

Validation:
  The assertion validates that the underlying findByRole method's case-insensitive comparison works correctly through the findAllActiveUsers method. This is important for data consistency when user roles may be entered with varying capitalization.

---

Scenario 9: Find All Active Users Returns Modifiable List

Details:
  TestName: findAllActiveUsersReturnsModifiableList
  Description: Verify that the returned list is a new ArrayList instance that can be modified without affecting the repository's internal state.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke the findAllActiveUsers() method and attempt to add or remove elements from the returned list.
  Assert: Verify that modifications to the returned list do not throw UnsupportedOperationException and do not affect subsequent calls to findAllActiveUsers().

Validation:
  The assertion confirms that the method returns a mutable ArrayList as specified in the implementation. This is important for callers who may need to filter or modify the result set for their specific use cases without affecting the repository.

---

Scenario 10: Find All Active Users With Concurrent Modifications

Details:
  TestName: findAllActiveUsersHandlesConcurrentAccess
  Description: Verify that the method operates correctly when the underlying ConcurrentHashMap is being accessed concurrently.

Execution:
  Arrange: Create a new UserRepository instance and prepare to invoke findAllActiveUsers() while simultaneously adding new users.
  Act: Invoke the findAllActiveUsers() method during concurrent save operations.
  Assert: Verify that the method completes without throwing ConcurrentModificationException and returns a valid list.

Validation:
  The assertion validates that the method is thread-safe due to the use of ConcurrentHashMap as the underlying storage. This is critical for multi-threaded applications where user queries and modifications may occur simultaneously.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryFindAllActiveUsersTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsUsersWithBothRoles() {
		// Arrange - UserRepository is initialized with default data in constructor
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertFalse(activeUsers.isEmpty());

		boolean hasUserRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("USER"));
		boolean hasAdminRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("ADMIN"));

		assertTrue(hasUserRole, "Should contain users with USER role");
		assertTrue(hasAdminRole, "Should contain users with ADMIN role");
	}

	@Test
	@Tag("boundary")
	void findAllActiveUsersReturnsEmptyListWhenNoUsersExist() {
		// Arrange - Clear all users from repository
		List<User> allUsers = userRepository.findAll();
		for (User user : allUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(0, activeUsers.size());
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsOnlyUsersWhenNoAdminsExist() {
		// Arrange - Remove all ADMIN users
		List<User> adminUsers = userRepository.findByRole("ADMIN");
		for (User admin : adminUsers) {
			userRepository.deleteById(admin.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertFalse(activeUsers.isEmpty());

		boolean hasAdminRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("ADMIN"));
		boolean hasUserRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("USER"));

		assertFalse(hasAdminRole, "Should not contain users with ADMIN role");
		assertTrue(hasUserRole, "Should contain users with USER role");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsOnlyAdminsWhenNoUsersExist() {
		// Arrange - Remove all USER role users
		List<User> regularUsers = userRepository.findByRole("USER");
		for (User user : regularUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertFalse(activeUsers.isEmpty());

		boolean hasUserRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("USER"));
		boolean hasAdminRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("ADMIN"));

		assertFalse(hasUserRole, "Should not contain users with USER role");
		assertTrue(hasAdminRole, "Should contain users with ADMIN role");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersExcludesNonUserAndNonAdminRoles() {
		// Arrange - Add a user with a different role
		User guestUser = new User("Guest User", "guest@example.com", "GUEST");
		userRepository.save(guestUser);

		User moderatorUser = new User("Moderator User", "moderator@example.com", "MODERATOR");
		userRepository.save(moderatorUser);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);

		boolean hasGuestRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("GUEST"));
		boolean hasModeratorRole = activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("MODERATOR"));

		assertFalse(hasGuestRole, "Should not contain users with GUEST role");
		assertFalse(hasModeratorRole, "Should not contain users with MODERATOR role");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsCorrectTotalCount() {
		// Arrange - Default initialization has 1 ADMIN and 2 USERs
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(3, activeUsers.size(), "Should return 3 users (1 ADMIN + 2 USERs)");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersIncludesNewlyAddedUsers() {
		// Arrange - Get initial count
		int initialCount = userRepository.findAllActiveUsers().size();

		// Add new users
		User newUser = new User("New User", "newuser@example.com", "USER");
		userRepository.save(newUser);

		User newAdmin = new User("New Admin", "newadmin@example.com", "ADMIN");
		userRepository.save(newAdmin);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(initialCount + 2, activeUsers.size(), "Should include newly added users");

		boolean containsNewUser = activeUsers.stream().anyMatch(user -> user.getEmail().equals("newuser@example.com"));
		boolean containsNewAdmin = activeUsers.stream()
			.anyMatch(user -> user.getEmail().equals("newadmin@example.com"));

		assertTrue(containsNewUser, "Should contain the newly added USER");
		assertTrue(containsNewAdmin, "Should contain the newly added ADMIN");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersHandlesCaseInsensitiveRoles() {
		// Arrange - Add users with different case roles
		User lowerCaseUser = new User("Lower Case User", "lowercase@example.com", "user");
		userRepository.save(lowerCaseUser);

		User mixedCaseAdmin = new User("Mixed Case Admin", "mixedcase@example.com", "Admin");
		userRepository.save(mixedCaseAdmin);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);

		boolean containsLowerCaseUser = activeUsers.stream()
			.anyMatch(user -> user.getEmail().equals("lowercase@example.com"));
		boolean containsMixedCaseAdmin = activeUsers.stream()
			.anyMatch(user -> user.getEmail().equals("mixedcase@example.com"));

		assertTrue(containsLowerCaseUser, "Should contain user with lowercase 'user' role");
		assertTrue(containsMixedCaseAdmin, "Should contain user with mixed case 'Admin' role");
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsModifiableList() {
		// Arrange
		List<User> activeUsers = userRepository.findAllActiveUsers();
		int originalSize = activeUsers.size();
		// Act & Assert - Should not throw UnsupportedOperationException
		assertDoesNotThrow(() -> {
			User newUser = new User("Test User", "test@example.com", "USER");
			activeUsers.add(newUser);
		});

		assertEquals(originalSize + 1, activeUsers.size(), "List should be modifiable");

		// Verify that modifying the returned list doesn't affect repository
		List<User> freshActiveUsers = userRepository.findAllActiveUsers();
		assertEquals(originalSize, freshActiveUsers.size(),
				"Repository should not be affected by modifications to returned list");
	}

	@Test
	@Tag("integration")
	void findAllActiveUsersHandlesConcurrentAccess() throws InterruptedException {
		// Arrange
		int numberOfThreads = 10;
		ExecutorService executorService = Executors.newFixedThreadPool(numberOfThreads);
		CountDownLatch latch = new CountDownLatch(numberOfThreads);
		// Act & Assert
		for (int i = 0; i < numberOfThreads; i++) {
			final int index = i;
			executorService.submit(() -> {
				try {
					// Concurrent read operations
					assertDoesNotThrow(() -> {
						List<User> activeUsers = userRepository.findAllActiveUsers();
						assertNotNull(activeUsers);
					});

					// Concurrent write operations
					if (index % 2 == 0) {
						User newUser = new User("Concurrent User " + index, "concurrent" + index + "@example.com",
								"USER");
						userRepository.save(newUser);
					}
				}
				finally {
					latch.countDown();
				}
			});
		}
		boolean completed = latch.await(5, TimeUnit.SECONDS);
		executorService.shutdown();

		assertTrue(completed, "All threads should complete without deadlock");

		// Final verification
		List<User> finalActiveUsers = userRepository.findAllActiveUsers();
		assertNotNull(finalActiveUsers);
		assertTrue(finalActiveUsers.size() >= 3, "Should have at least the original users");
	}

}