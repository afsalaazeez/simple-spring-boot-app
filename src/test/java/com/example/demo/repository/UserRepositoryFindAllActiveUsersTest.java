
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findAllActiveUsers_193540cac3
ROOST_METHOD_SIG_HASH=findAllActiveUsers_31324daed4

Scenario 1: Find All Active Users When Both USER and ADMIN Roles Exist

Details:
  TestName: findAllActiveUsersReturnsUsersAndAdmins
  Description: Verify that the method returns a combined list of users with both "USER" and "ADMIN" roles when both types exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance. The constructor automatically initializes the repository with sample data containing users with both "USER" and "ADMIN" roles.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list is not null, contains exactly 3 users (1 ADMIN and 2 USERs based on default initialization), and includes users with both roles.

Validation:
  The assertion verifies that the method correctly aggregates users from both role categories. This is significant because the method is designed to return all active users regardless of whether they are regular users or administrators, ensuring complete visibility of active accounts in the system.

---

Scenario 2: Find All Active Users When Repository Is Empty

Details:
  TestName: findAllActiveUsersReturnsEmptyListWhenNoUsers
  Description: Verify that the method returns an empty list when the repository contains no users.

Execution:
  Arrange: Create a new UserRepository instance and clear all users by calling deleteById() for each existing user, or create a scenario where the internal users map is empty.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list is not null and is empty (size equals 0).

Validation:
  The assertion confirms that the method handles the edge case of an empty repository gracefully without throwing exceptions. This is important for application stability when the system is freshly initialized or when all users have been removed.

---

Scenario 3: Find All Active Users When Only USER Role Exists

Details:
  TestName: findAllActiveUsersReturnsOnlyUsersWhenNoAdmins
  Description: Verify that the method returns only users with "USER" role when no "ADMIN" role users exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance. Delete the default ADMIN user and ensure only USER role users remain by using deleteById() on the admin user.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list contains only users with "USER" role and the count matches the expected number of USER role users.

Validation:
  The assertion verifies that the method correctly handles scenarios where one role category is absent. This ensures the method doesn't fail or return incorrect results when the ADMIN role has no members.

---

Scenario 4: Find All Active Users When Only ADMIN Role Exists

Details:
  TestName: findAllActiveUsersReturnsOnlyAdminsWhenNoUsers
  Description: Verify that the method returns only users with "ADMIN" role when no "USER" role users exist in the repository.

Execution:
  Arrange: Create a new UserRepository instance. Delete all users with "USER" role using deleteById() method, leaving only ADMIN users.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list contains only users with "ADMIN" role and the count matches the expected number of ADMIN role users.

Validation:
  The assertion verifies that the method correctly handles scenarios where the USER role category is empty. This is important for systems that might temporarily have only administrative accounts.

---

Scenario 5: Find All Active Users Excludes Other Roles

Details:
  TestName: findAllActiveUsersExcludesNonUserAndNonAdminRoles
  Description: Verify that the method does not include users with roles other than "USER" or "ADMIN" (e.g., "GUEST", "MODERATOR").

Execution:
  Arrange: Create a new UserRepository instance. Add additional users with different roles such as "GUEST" or "MODERATOR" using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list contains only users with "USER" or "ADMIN" roles and excludes users with other roles.

Validation:
  The assertion confirms that the method strictly filters for only the two specified roles. This is crucial for security and access control, ensuring that only designated active user types are returned.

---

Scenario 6: Find All Active Users With Case Insensitive Role Matching

Details:
  TestName: findAllActiveUsersHandlesCaseInsensitiveRoles
  Description: Verify that the method correctly finds users regardless of the case used for role values (e.g., "user", "User", "USER").

Execution:
  Arrange: Create a new UserRepository instance. Add users with various case variations of roles such as "user", "User", "admin", "Admin" using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that all users with case-insensitive matches to "USER" and "ADMIN" are included in the returned list.

Validation:
  The assertion verifies that the underlying findByRole() method's case-insensitive comparison works correctly when called by findAllActiveUsers(). This ensures data consistency regardless of how role values were stored.

---

Scenario 7: Find All Active Users Returns Mutable List

Details:
  TestName: findAllActiveUsersReturnsMutableList
  Description: Verify that the returned list is mutable and can be modified without affecting the repository's internal state.

Execution:
  Arrange: Create a new UserRepository instance with default data.
  Act: Invoke the findAllActiveUsers() method and attempt to add or remove elements from the returned list.
  Assert: Verify that modifications to the returned list do not throw exceptions and do not affect subsequent calls to findAllActiveUsers().

Validation:
  The assertion confirms that the method returns a new ArrayList instance that is independent of the repository's internal data structure. This is important for preventing unintended side effects when callers manipulate the returned list.

---

Scenario 8: Find All Active Users After Adding New Users

Details:
  TestName: findAllActiveUsersReflectsNewlyAddedUsers
  Description: Verify that the method includes users that were added to the repository after the initial setup.

Execution:
  Arrange: Create a new UserRepository instance. Add new users with "USER" and "ADMIN" roles using the save() method.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list includes both the original users and the newly added users.

Validation:
  The assertion verifies that the method always queries the current state of the repository and reflects any changes made. This ensures real-time accuracy of the active users list.

---

Scenario 9: Find All Active Users After Deleting Users

Details:
  TestName: findAllActiveUsersReflectsDeletedUsers
  Description: Verify that the method excludes users that have been deleted from the repository.

Execution:
  Arrange: Create a new UserRepository instance. Delete one or more users using the deleteById() method.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that the returned list does not contain the deleted users and the count is reduced accordingly.

Validation:
  The assertion confirms that the method accurately reflects the current state of the repository after deletions. This is essential for maintaining data integrity and ensuring removed users are not returned.

---

Scenario 10: Find All Active Users Maintains Order Consistency

Details:
  TestName: findAllActiveUsersReturnsUsersBeforeAdmins
  Description: Verify that the method returns USER role users before ADMIN role users in the result list, as per the implementation order.

Execution:
  Arrange: Create a new UserRepository instance with default data containing both USER and ADMIN role users.
  Act: Invoke the findAllActiveUsers() method on the repository instance.
  Assert: Verify that in the returned list, users with "USER" role appear before users with "ADMIN" role, reflecting the order in which findByRole() is called.

Validation:
  The assertion verifies the predictable ordering of results based on the method's implementation. While not strictly a business requirement, consistent ordering can be important for UI display and testing predictability.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryFindAllActiveUsersTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsUsersAndAdmins() {
		// Arrange - repository is initialized with default data in constructor
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(3, activeUsers.size());

		long adminCount = activeUsers.stream().filter(user -> user.getRole().equalsIgnoreCase("ADMIN")).count();
		long userCount = activeUsers.stream().filter(user -> user.getRole().equalsIgnoreCase("USER")).count();

		assertEquals(1, adminCount);
		assertEquals(2, userCount);
	}

	@Test
	@Tag("boundary")
	void findAllActiveUsersReturnsEmptyListWhenNoUsers() {
		// Arrange - delete all existing users
		List<User> allUsers = userRepository.findAll();
		for (User user : allUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertTrue(activeUsers.isEmpty());
		assertEquals(0, activeUsers.size());
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsOnlyUsersWhenNoAdmins() {
		// Arrange - delete the ADMIN user
		List<User> admins = userRepository.findByRole("ADMIN");
		for (User admin : admins) {
			userRepository.deleteById(admin.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(2, activeUsers.size());
		assertTrue(activeUsers.stream().allMatch(user -> user.getRole().equalsIgnoreCase("USER")));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsOnlyAdminsWhenNoUsers() {
		// Arrange - delete all USER role users
		List<User> users = userRepository.findByRole("USER");
		for (User user : users) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(1, activeUsers.size());
		assertTrue(activeUsers.stream().allMatch(user -> user.getRole().equalsIgnoreCase("ADMIN")));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersExcludesNonUserAndNonAdminRoles() {
		// Arrange - add users with different roles
		User guestUser = new User("Guest User", "guest@example.com", "GUEST");
		User moderatorUser = new User("Moderator User", "moderator@example.com", "MODERATOR");
		userRepository.save(guestUser);
		userRepository.save(moderatorUser);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(3, activeUsers.size()); // Only original 3 users (1 ADMIN + 2 USER)
		assertTrue(activeUsers.stream()
			.allMatch(user -> user.getRole().equalsIgnoreCase("USER") || user.getRole().equalsIgnoreCase("ADMIN")));
		assertFalse(activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("GUEST")));
		assertFalse(activeUsers.stream().anyMatch(user -> user.getRole().equalsIgnoreCase("MODERATOR")));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersHandlesCaseInsensitiveRoles() {
		// Arrange - add users with various case variations
		User lowerCaseUser = new User("Lower Case User", "lowercase@example.com", "user");
		User mixedCaseUser = new User("Mixed Case User", "mixedcase@example.com", "User");
		User lowerCaseAdmin = new User("Lower Case Admin", "lowercaseadmin@example.com", "admin");
		User mixedCaseAdmin = new User("Mixed Case Admin", "mixedcaseadmin@example.com", "Admin");

		userRepository.save(lowerCaseUser);
		userRepository.save(mixedCaseUser);
		userRepository.save(lowerCaseAdmin);
		userRepository.save(mixedCaseAdmin);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(7, activeUsers.size()); // 3 original + 4 new users
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsMutableList() {
		// Arrange
		int originalSize = userRepository.findAllActiveUsers().size();
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		User newUser = new User("Test User", "test@example.com", "USER");
		activeUsers.add(newUser);
		// Assert - modifications to returned list should not affect repository
		List<User> activeUsersAfterModification = userRepository.findAllActiveUsers();
		assertEquals(originalSize, activeUsersAfterModification.size());
		assertDoesNotThrow(() -> activeUsers.remove(0));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReflectsNewlyAddedUsers() {
		// Arrange
		int initialCount = userRepository.findAllActiveUsers().size();
		User newUser = new User("New User", "newuser@example.com", "USER");
		User newAdmin = new User("New Admin", "newadmin@example.com", "ADMIN");
		userRepository.save(newUser);
		userRepository.save(newAdmin);
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(initialCount + 2, activeUsers.size());
		assertTrue(activeUsers.stream().anyMatch(user -> user.getEmail().equals("newuser@example.com")));
		assertTrue(activeUsers.stream().anyMatch(user -> user.getEmail().equals("newadmin@example.com")));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReflectsDeletedUsers() {
		// Arrange
		int initialCount = userRepository.findAllActiveUsers().size();
		List<User> users = userRepository.findByRole("USER");
		User userToDelete = users.get(0);
		userRepository.deleteById(userToDelete.getId());
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);
		assertEquals(initialCount - 1, activeUsers.size());
		assertFalse(activeUsers.stream().anyMatch(user -> user.getId().equals(userToDelete.getId())));
	}

	@Test
	@Tag("valid")
	void findAllActiveUsersReturnsUsersBeforeAdmins() {
		// Arrange - repository is initialized with default data
		// Act
		List<User> activeUsers = userRepository.findAllActiveUsers();
		// Assert
		assertNotNull(activeUsers);

		// Find the index of first ADMIN
		int firstAdminIndex = -1;
		int lastUserIndex = -1;

		for (int i = 0; i < activeUsers.size(); i++) {
			User user = activeUsers.get(i);
			if (user.getRole().equalsIgnoreCase("USER")) {
				lastUserIndex = i;
			}
			else if (user.getRole().equalsIgnoreCase("ADMIN") && firstAdminIndex == -1) {
				firstAdminIndex = i;
			}
		}

		// If both roles exist, USERs should come before ADMINs
		if (firstAdminIndex != -1 && lastUserIndex != -1) {
			assertTrue(lastUserIndex < firstAdminIndex || activeUsers.stream()
				.filter(u -> u.getRole().equalsIgnoreCase("USER"))
				.count() == activeUsers.stream().takeWhile(u -> u.getRole().equalsIgnoreCase("USER")).count());
		}
	}

}