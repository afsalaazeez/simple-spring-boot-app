
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findByPriceRange_a4910d76fa
ROOST_METHOD_SIG_HASH=findByPriceRange_30ce6d6836

Scenario 1: Find Products Within Valid Price Range

Details:
  TestName: findProductsWithinValidPriceRange
  Description: Verify that the method returns all products whose prices fall within the specified minimum and maximum price range (inclusive on both ends).

Execution:
  Arrange: Create a ProductRepository instance which initializes with sample data containing products at various price points (29.99, 89.99, 199.99, 399.99, 999.99).
  Act: Invoke findByPriceRange with minPrice = 50.00 and maxPrice = 250.00.
  Assert: Verify that the returned list contains exactly 2 products (Keyboard at 89.99 and Headphones at 199.99).

Validation:
  The assertion verifies that only products with prices >= 50.00 AND <= 250.00 are returned. This test confirms the core filtering logic works correctly for a typical use case where multiple products fall within the range.

---

Scenario 2: Find Products With Exact Boundary Prices

Details:
  TestName: findProductsWithExactBoundaryPrices
  Description: Verify that products with prices exactly equal to minPrice or maxPrice are included in the results (boundary inclusivity test).

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 29.99 and maxPrice = 89.99.
  Assert: Verify that the returned list contains exactly 2 products (Mouse at 29.99 and Keyboard at 89.99).

Validation:
  The assertion confirms that the compareTo method correctly includes boundary values using >= 0 for minPrice and <= 0 for maxPrice. This is critical for ensuring users get expected results when searching for exact price points.

---

Scenario 3: Find Products When No Products Match Price Range

Details:
  TestName: findProductsWhenNoPricesInRange
  Description: Verify that an empty list is returned when no products have prices within the specified range.

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 1000.00 and maxPrice = 2000.00.
  Assert: Verify that the returned list is empty (size = 0).

Validation:
  The assertion ensures the method handles cases where no products match the criteria gracefully by returning an empty list rather than null. This is important for preventing NullPointerExceptions in calling code.

---

Scenario 4: Find Products With Same Min and Max Price

Details:
  TestName: findProductsWithSameMinAndMaxPrice
  Description: Verify that when minPrice equals maxPrice, only products with that exact price are returned.

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 199.99 and maxPrice = 199.99.
  Assert: Verify that the returned list contains exactly 1 product (Headphones at 199.99).

Validation:
  The assertion confirms that the method correctly handles the edge case where the price range is a single value. This validates that both boundary conditions work together when they are equal.

---

Scenario 5: Find All Products With Wide Price Range

Details:
  TestName: findAllProductsWithWideRange
  Description: Verify that all products are returned when the price range encompasses all product prices.

Execution:
  Arrange: Create a ProductRepository instance with default sample data (5 products).
  Act: Invoke findByPriceRange with minPrice = 0.00 and maxPrice = 10000.00.
  Assert: Verify that the returned list contains all 5 products.

Validation:
  The assertion ensures that a sufficiently wide range captures all products in the repository. This validates the method works correctly when all products should be included.

---

Scenario 6: Find Products With Zero As Minimum Price

Details:
  TestName: findProductsWithZeroMinPrice
  Description: Verify that the method correctly handles zero as the minimum price boundary.

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 0.00 and maxPrice = 50.00.
  Assert: Verify that the returned list contains exactly 1 product (Mouse at 29.99).

Validation:
  The assertion confirms that BigDecimal.ZERO is handled correctly as a lower bound. This is important for scenarios where users want to find the cheapest products starting from zero.

---

Scenario 7: Find Products After Adding New Product In Range

Details:
  TestName: findProductsAfterAddingNewProductInRange
  Description: Verify that newly added products within the price range are included in search results.

Execution:
  Arrange: Create a ProductRepository instance and save a new Product with name "USB Cable", description "USB-C cable", price 15.99, and quantity 100.
  Act: Invoke findByPriceRange with minPrice = 10.00 and maxPrice = 20.00.
  Assert: Verify that the returned list contains the newly added USB Cable product.

Validation:
  The assertion ensures that the ConcurrentHashMap backing store is properly queried and newly added products are immediately available for price range searches. This validates the integration between save and findByPriceRange methods.

---

Scenario 8: Find Products With Very Small Price Range

Details:
  TestName: findProductsWithVerySmallPriceRange
  Description: Verify that the method correctly filters products when the price range is very narrow but does not match any product exactly.

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 30.00 and maxPrice = 30.01.
  Assert: Verify that the returned list is empty.

Validation:
  The assertion confirms that the BigDecimal comparison is precise and does not include products outside the specified narrow range. This validates the precision of decimal comparisons.

---

Scenario 9: Find Products On Empty Repository

Details:
  TestName: findProductsOnEmptyRepository
  Description: Verify that the method returns an empty list when the repository contains no products.

Execution:
  Arrange: Create a ProductRepository instance, then delete all products using deleteById for each existing product ID (1 through 5).
  Act: Invoke findByPriceRange with minPrice = 0.00 and maxPrice = 1000.00.
  Assert: Verify that the returned list is empty.

Validation:
  The assertion ensures the method handles an empty products map gracefully without throwing exceptions. This is important for robustness when the repository is in an initial or cleared state.

---

Scenario 10: Find Products With High Precision Decimal Prices

Details:
  TestName: findProductsWithHighPrecisionDecimalPrices
  Description: Verify that BigDecimal precision is maintained when filtering products by price range.

Execution:
  Arrange: Create a ProductRepository instance and save a new Product with price 99.999 (high precision).
  Act: Invoke findByPriceRange with minPrice = 99.99 and maxPrice = 100.00.
  Assert: Verify that the returned list contains the product with price 99.999.

Validation:
  The assertion confirms that BigDecimal comparisons handle varying decimal precision correctly. This is crucial for financial applications where price precision matters.

---

Scenario 11: Verify Returned List Is Immutable

Details:
  TestName: verifyReturnedListFromToListIsUnmodifiable
  Description: Verify that the list returned by findByPriceRange is the result of toList() which creates an unmodifiable list in Java 16+.

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 0.00 and maxPrice = 100.00 and attempt to add a new element to the returned list.
  Assert: Verify that an UnsupportedOperationException is thrown when attempting to modify the returned list.

Validation:
  The assertion confirms that the toList() method returns an unmodifiable list, which is the expected behavior. This ensures data integrity by preventing accidental modifications to the returned collection.

---

Scenario 12: Find Products With Inverted Price Range

Details:
  TestName: findProductsWithInvertedPriceRange
  Description: Verify the method behavior when minPrice is greater than maxPrice (inverted range).

Execution:
  Arrange: Create a ProductRepository instance with default sample data.
  Act: Invoke findByPriceRange with minPrice = 500.00 and maxPrice = 100.00.
  Assert: Verify that the returned list is empty since no product can satisfy price >= 500 AND price <= 100 simultaneously.

Validation:
  The assertion confirms that the method handles logically impossible ranges by returning an empty list. While this may indicate a caller error, the method should not throw an exception for this input.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryFindByPriceRangeTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void findProductsWithinValidPriceRange() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("50.00"), new BigDecimal("250.00"));
		// Assert
		assertEquals(2, result.size());
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Keyboard")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Headphones")));
	}

	@Test
	@Tag("boundary")
	void findProductsWithExactBoundaryPrices() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("29.99"), new BigDecimal("89.99"));
		// Assert
		assertEquals(2, result.size());
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Mouse")));
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Keyboard")));
	}

	@Test
	@Tag("valid")
	void findProductsWhenNoPricesInRange() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("1000.00"), new BigDecimal("2000.00"));
		// Assert
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("boundary")
	void findProductsWithSameMinAndMaxPrice() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("199.99"), new BigDecimal("199.99"));
		// Assert
		assertEquals(1, result.size());
		assertEquals("Headphones", result.get(0).getName());
	}

	@Test
	@Tag("valid")
	void findAllProductsWithWideRange() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("0.00"), new BigDecimal("10000.00"));
		// Assert
		assertEquals(5, result.size());
	}

	@Test
	@Tag("boundary")
	void findProductsWithZeroMinPrice() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("0.00"), new BigDecimal("50.00"));
		// Assert
		assertEquals(1, result.size());
		assertEquals("Mouse", result.get(0).getName());
	}

	@Test
	@Tag("integration")
	void findProductsAfterAddingNewProductInRange() {
		// Arrange
		Product newProduct = new Product("USB Cable", "USB-C cable", new BigDecimal("15.99"), 100);
		productRepository.save(newProduct);
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("10.00"), new BigDecimal("20.00"));
		// Assert
		assertEquals(1, result.size());
		assertEquals("USB Cable", result.get(0).getName());
	}

	@Test
	@Tag("boundary")
	void findProductsWithVerySmallPriceRange() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("30.00"), new BigDecimal("30.01"));
		// Assert
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("boundary")
	void findProductsOnEmptyRepository() {
		// Arrange - delete all products
		for (long i = 1; i <= 5; i++) {
			productRepository.deleteById(i);
		}
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("0.00"), new BigDecimal("1000.00"));
		// Assert
		assertTrue(result.isEmpty());
	}

	@Test
	@Tag("valid")
	void findProductsWithHighPrecisionDecimalPrices() {
		// Arrange
		Product highPrecisionProduct = new Product("Precision Item", "High precision price", new BigDecimal("99.999"),
				10);
		productRepository.save(highPrecisionProduct);
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("99.99"), new BigDecimal("100.00"));
		// Assert
		assertTrue(result.stream().anyMatch(p -> p.getName().equals("Precision Item")));
	}

	@Test
	@Tag("valid")
	void verifyReturnedListFromToListIsUnmodifiable() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("0.00"), new BigDecimal("100.00"));
		// Assert
		assertThrows(UnsupportedOperationException.class, () -> {
			result.add(new Product("Test", "Test", new BigDecimal("50.00"), 1));
		});
	}

	@Test
	@Tag("invalid")
	void findProductsWithInvertedPriceRange() {
		// Arrange - repository is initialized with sample data in constructor
		// Act
		List<Product> result = productRepository.findByPriceRange(new BigDecimal("500.00"), new BigDecimal("100.00"));
		// Assert
		assertTrue(result.isEmpty());
	}

}