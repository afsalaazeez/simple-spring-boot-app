
// ********RoostGPT********
/*
Test generated by RoostGPT for test Dec-3-Java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=findByRole_4e812975c2
ROOST_METHOD_SIG_HASH=findByRole_061d7e628f

Scenario 1: Find Users by Role with Exact Case Match

Details:
  TestName: findByRoleWithExactCaseMatch
  Description: Verify that the method returns users when the role parameter matches the stored role with exact case (e.g., "USER" matches "USER").

Execution:
  Arrange: Create a new UserRepository instance which initializes with sample data containing users with roles "ADMIN" and "USER".
  Act: Invoke findByRole("USER") method.
  Assert: Verify that the returned list contains exactly 2 users (Bob Smith and Charlie Brown based on default initialization).

Validation:
  The assertion verifies that users with the exact role match are correctly retrieved. This is important for role-based access control where users need to be filtered by their assigned roles.

---

Scenario 2: Find Users by Role with Different Case (Case Insensitivity)

Details:
  TestName: findByRoleWithDifferentCaseReturnsMatchingUsers
  Description: Verify that the method performs case-insensitive comparison when searching for users by role (e.g., "user" matches "USER").

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke findByRole("user") method with lowercase role.
  Assert: Verify that the returned list contains the same users as when searching with uppercase "USER".

Validation:
  The assertion confirms that the equalsIgnoreCase comparison works correctly, allowing flexible role queries regardless of case. This improves user experience and prevents errors due to case sensitivity.

---

Scenario 3: Find Users by Role with Mixed Case

Details:
  TestName: findByRoleWithMixedCaseReturnsMatchingUsers
  Description: Verify that the method handles mixed case role parameters correctly (e.g., "UsEr" matches "USER").

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke findByRole("UsEr") method with mixed case role.
  Assert: Verify that the returned list contains users with "USER" role.

Validation:
  The assertion ensures that any case variation of the role string will successfully match stored roles. This is crucial for robust API behavior when role parameters come from various sources.

---

Scenario 4: Find Users by Non-Existent Role Returns Empty List

Details:
  TestName: findByRoleWithNonExistentRoleReturnsEmptyList
  Description: Verify that the method returns an empty list when no users have the specified role.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke findByRole("MANAGER") method with a role that doesn't exist.
  Assert: Verify that the returned list is empty and not null.

Validation:
  The assertion confirms that the method gracefully handles queries for non-existent roles by returning an empty list rather than null. This prevents NullPointerException in calling code.

---

Scenario 5: Find Users by ADMIN Role

Details:
  TestName: findByRoleAdminReturnsSingleUser
  Description: Verify that the method correctly returns users with ADMIN role from the default initialized data.

Execution:
  Arrange: Create a new UserRepository instance which initializes with one ADMIN user (Alice Johnson).
  Act: Invoke findByRole("ADMIN") method.
  Assert: Verify that the returned list contains exactly 1 user.

Validation:
  The assertion verifies that ADMIN role filtering works correctly. This is essential for administrative functions that need to identify system administrators.

---

Scenario 6: Find Users by Role After Adding New User with Same Role

Details:
  TestName: findByRoleAfterAddingNewUserWithSameRole
  Description: Verify that newly added users with a specific role are included in subsequent findByRole queries.

Execution:
  Arrange: Create a new UserRepository instance and save a new User with role "USER".
  Act: Invoke findByRole("USER") method.
  Assert: Verify that the returned list contains 3 users (2 default + 1 newly added).

Validation:
  The assertion confirms that the repository correctly includes newly added users in role-based queries. This validates the integration between save and findByRole operations.

---

Scenario 7: Find Users by Role with Empty String

Details:
  TestName: findByRoleWithEmptyStringReturnsEmptyList
  Description: Verify that the method handles empty string role parameter and returns an empty list when no users have an empty role.

Execution:
  Arrange: Create a new UserRepository instance with default sample data (all users have non-empty roles).
  Act: Invoke findByRole("") method with empty string.
  Assert: Verify that the returned list is empty.

Validation:
  The assertion ensures that edge case of empty string role is handled correctly. This prevents unexpected behavior when invalid role parameters are passed.

---

Scenario 8: Find Users by Role After Deleting User

Details:
  TestName: findByRoleAfterDeletingUserReturnsUpdatedList
  Description: Verify that deleted users are not included in findByRole results.

Execution:
  Arrange: Create a new UserRepository instance, find a user by role "USER", then delete one of them using deleteById.
  Act: Invoke findByRole("USER") method after deletion.
  Assert: Verify that the returned list contains one fewer user than before deletion.

Validation:
  The assertion confirms that the repository maintains consistency between delete operations and query results. This is critical for data integrity.

---

Scenario 9: Find Users by Role with Whitespace-Padded Role

Details:
  TestName: findByRoleWithWhitespacePaddedRoleReturnsEmptyList
  Description: Verify that the method does not trim whitespace from role parameter, so " USER " does not match "USER".

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke findByRole(" USER ") method with whitespace-padded role.
  Assert: Verify that the returned list is empty since equalsIgnoreCase does not trim whitespace.

Validation:
  The assertion documents the expected behavior that whitespace is significant in role comparison. This helps developers understand they need to trim input before calling this method.

---

Scenario 10: Find Users by Role Returns Immutable or New List

Details:
  TestName: findByRoleReturnsListThatDoesNotAffectInternalState
  Description: Verify that modifying the returned list does not affect the internal repository state.

Execution:
  Arrange: Create a new UserRepository instance and call findByRole("USER") to get a list.
  Act: Attempt to clear or modify the returned list, then call findByRole("USER") again.
  Assert: Verify that the second call still returns the original number of users.

Validation:
  The assertion confirms that the toList() method creates a new list, protecting the internal state from external modification. This is important for thread safety and data integrity.

---

Scenario 11: Find Users by Role in Empty Repository

Details:
  TestName: findByRoleInEmptyRepositoryReturnsEmptyList
  Description: Verify that the method returns an empty list when the repository has no users.

Execution:
  Arrange: Create a new UserRepository instance and delete all default users using deleteById for each user.
  Act: Invoke findByRole("USER") method.
  Assert: Verify that the returned list is empty.

Validation:
  The assertion ensures that the method handles empty repository state gracefully without throwing exceptions. This is important for newly initialized or cleared repositories.

---

Scenario 12: Find Users by Role with Special Characters

Details:
  TestName: findByRoleWithSpecialCharactersReturnsEmptyList
  Description: Verify that the method handles role parameters containing special characters without throwing exceptions.

Execution:
  Arrange: Create a new UserRepository instance with default sample data.
  Act: Invoke findByRole("USER@#$%") method with special characters.
  Assert: Verify that the returned list is empty and no exception is thrown.

Validation:
  The assertion confirms that the method is robust against unusual input and does not crash when given special characters. This is important for security and stability.

---

Scenario 13: Find Users by Role Concurrent Access

Details:
  TestName: findByRoleDuringConcurrentModification
  Description: Verify that findByRole works correctly when users are being added concurrently, leveraging ConcurrentHashMap's thread safety.

Execution:
  Arrange: Create a new UserRepository instance.
  Act: Invoke findByRole("USER") while simultaneously saving new users in a separate thread.
  Assert: Verify that the method completes without ConcurrentModificationException.

Validation:
  The assertion validates that the ConcurrentHashMap backing store provides thread-safe iteration. This is critical for multi-threaded application environments.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class UserRepositoryFindByRoleTest {

	private UserRepository userRepository;

	@BeforeEach
	void setUp() {
		userRepository = new UserRepository();
	}

	@Test
	@Tag("valid")
	void findByRoleWithExactCaseMatch() {
		// Arrange - UserRepository is initialized with default data in constructor
		// Act
		List<User> users = userRepository.findByRole("USER");
		// Assert
		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.stream().allMatch(user -> user.getRole().equalsIgnoreCase("USER")));
	}

	@Test
	@Tag("valid")
	void findByRoleWithDifferentCaseReturnsMatchingUsers() {
		// Arrange - UserRepository is initialized with default data in constructor
		// Act
		List<User> users = userRepository.findByRole("user");
		// Assert
		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.stream().allMatch(user -> user.getRole().equalsIgnoreCase("USER")));
	}

	@Test
	@Tag("valid")
	void findByRoleWithMixedCaseReturnsMatchingUsers() {
		// Arrange - UserRepository is initialized with default data in constructor
		// Act
		List<User> users = userRepository.findByRole("UsEr");
		// Assert
		assertNotNull(users);
		assertEquals(2, users.size());
		assertTrue(users.stream().allMatch(user -> user.getRole().equalsIgnoreCase("USER")));
	}

	@Test
	@Tag("invalid")
	void findByRoleWithNonExistentRoleReturnsEmptyList() {
		// Arrange - UserRepository is initialized with default data in constructor
		// Act
		List<User> users = userRepository.findByRole("MANAGER");
		// Assert
		assertNotNull(users);
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("valid")
	void findByRoleAdminReturnsSingleUser() {
		// Arrange - UserRepository is initialized with one ADMIN user (Alice Johnson)
		// Act
		List<User> users = userRepository.findByRole("ADMIN");
		// Assert
		assertNotNull(users);
		assertEquals(1, users.size());
		assertEquals("ADMIN", users.get(0).getRole());
	}

	@Test
	@Tag("integration")
	void findByRoleAfterAddingNewUserWithSameRole() {
		// Arrange
		User newUser = new User("David Wilson", "david@example.com", "USER");
		userRepository.save(newUser);
		// Act
		List<User> users = userRepository.findByRole("USER");
		// Assert
		assertNotNull(users);
		assertEquals(3, users.size());
		assertTrue(users.stream().allMatch(user -> user.getRole().equalsIgnoreCase("USER")));
	}

	@Test
	@Tag("boundary")
	void findByRoleWithEmptyStringReturnsEmptyList() {
		// Arrange - UserRepository is initialized with default data (all users have
		// non-empty roles)
		// Act
		List<User> users = userRepository.findByRole("");
		// Assert
		assertNotNull(users);
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("integration")
	void findByRoleAfterDeletingUserReturnsUpdatedList() {
		// Arrange
		List<User> initialUsers = userRepository.findByRole("USER");
		int initialCount = initialUsers.size();
		Long userIdToDelete = initialUsers.get(0).getId();
		userRepository.deleteById(userIdToDelete);
		// Act
		List<User> users = userRepository.findByRole("USER");
		// Assert
		assertNotNull(users);
		assertEquals(initialCount - 1, users.size());
	}

	@Test
	@Tag("boundary")
	void findByRoleWithWhitespacePaddedRoleReturnsEmptyList() {
		// Arrange - UserRepository is initialized with default data
		// Act
		List<User> users = userRepository.findByRole(" USER ");
		// Assert
		assertNotNull(users);
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("valid")
	void findByRoleReturnsListThatDoesNotAffectInternalState() {
		// Arrange
		List<User> firstResult = userRepository.findByRole("USER");
		int initialCount = firstResult.size();
		// Act - Attempt to modify the returned list
		try {
			firstResult.clear();
		}
		catch (UnsupportedOperationException e) {
			// toList() returns an unmodifiable list in Java 16+
		}
		List<User> secondResult = userRepository.findByRole("USER");
		// Assert
		assertNotNull(secondResult);
		assertEquals(initialCount, secondResult.size());
	}

	@Test
	@Tag("boundary")
	void findByRoleInEmptyRepositoryReturnsEmptyList() {
		// Arrange - Delete all default users
		List<User> allUsers = userRepository.findAll();
		for (User user : allUsers) {
			userRepository.deleteById(user.getId());
		}
		// Act
		List<User> users = userRepository.findByRole("USER");
		// Assert
		assertNotNull(users);
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("invalid")
	void findByRoleWithSpecialCharactersReturnsEmptyList() {
		// Arrange - UserRepository is initialized with default data
		// Act
		List<User> users = userRepository.findByRole("USER@#$%");
		// Assert
		assertNotNull(users);
		assertTrue(users.isEmpty());
	}

	@Test
	@Tag("integration")
	void findByRoleDuringConcurrentModification() throws InterruptedException {
		// Arrange
		ExecutorService executor = Executors.newFixedThreadPool(2);
		CountDownLatch latch = new CountDownLatch(2);
		// Act & Assert
		assertDoesNotThrow(() -> {
			executor.submit(() -> {
				try {
					for (int i = 0; i < 100; i++) {
						userRepository.save(new User("User" + i, "user" + i + "@example.com", "USER"));
					}
				}
				finally {
					latch.countDown();
				}
			});
			executor.submit(() -> {
				try {
					for (int i = 0; i < 100; i++) {
						List<User> users = userRepository.findByRole("USER");
						assertNotNull(users);
					}
				}
				finally {
					latch.countDown();
				}
			});
			latch.await(10, TimeUnit.SECONDS);
			executor.shutdown();
		});
		// Final verification
		List<User> finalUsers = userRepository.findByRole("USER");
		assertNotNull(finalUsers);
		assertTrue(finalUsers.size() >= 2); // At least the original 2 users
	}

}