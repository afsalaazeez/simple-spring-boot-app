
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-simple using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=existsById_9b21d91b5f
ROOST_METHOD_SIG_HASH=existsById_83b9bf1592

Scenario 1: Check if product exists with a valid existing ID

Details:
  TestName: existsByIdReturnsTrueForExistingProduct
  Description: Verify that the existsById method returns true when checking for a product ID that exists in the repository. This tests the basic positive case where a product has been saved and we verify its existence.

Execution:
  Arrange: Create a new ProductRepository instance. The constructor automatically initializes the repository with sample products (IDs 1-5).
  Act: Call existsById with ID 1L (which corresponds to the first sample product "Laptop").
  Assert: Assert that the returned value is true.

Validation:
  The assertion verifies that the method correctly identifies an existing product in the ConcurrentHashMap. This is critical for business logic that needs to validate product existence before performing operations like updates or retrievals.

---

Scenario 2: Check if product exists with a non-existing ID

Details:
  TestName: existsByIdReturnsFalseForNonExistingProduct
  Description: Verify that the existsById method returns false when checking for a product ID that does not exist in the repository. This tests the negative case where the requested ID has never been assigned.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data (5 products with IDs 1-5).
  Act: Call existsById with ID 100L (an ID that was never assigned).
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method correctly returns false for non-existent products. This is essential for preventing operations on invalid product IDs and maintaining data integrity.

---

Scenario 3: Check if product exists with null ID

Details:
  TestName: existsByIdReturnsFalseForNullId
  Description: Verify the behavior of existsById when called with a null ID parameter. Since ConcurrentHashMap's containsKey method throws NullPointerException for null keys, this tests error handling.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Call existsById with null as the parameter.
  Assert: Expect a NullPointerException to be thrown.

Validation:
  This test validates the method's behavior with invalid input. ConcurrentHashMap does not allow null keys, so this scenario documents the expected exception behavior, which is important for callers to handle appropriately.

---

Scenario 4: Check if product exists after saving a new product

Details:
  TestName: existsByIdReturnsTrueAfterSavingNewProduct
  Description: Verify that existsById returns true for a newly saved product. This tests the integration between save and existsById methods.

Execution:
  Arrange: Create a new ProductRepository instance. Create a new Product with name "Test Product", description "Test Description", price BigDecimal("50.00"), and quantity 10. Save the product using the save method and capture the returned product with its assigned ID.
  Act: Call existsById with the ID of the saved product.
  Assert: Assert that the returned value is true.

Validation:
  This test verifies that products are correctly stored and can be found after being saved. It confirms the consistency between save and existsById operations, which is crucial for repository reliability.

---

Scenario 5: Check if product exists after deletion

Details:
  TestName: existsByIdReturnsFalseAfterDeletion
  Description: Verify that existsById returns false for a product that has been deleted. This tests the integration between deleteById and existsById methods.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data. Confirm that product with ID 1L exists initially by calling existsById. Delete the product with ID 1L using deleteById method.
  Act: Call existsById with ID 1L.
  Assert: Assert that the returned value is false.

Validation:
  This test ensures that deleted products are properly removed from the repository and no longer reported as existing. This is critical for maintaining accurate inventory state and preventing operations on deleted items.

---

Scenario 6: Check if product exists with ID zero

Details:
  TestName: existsByIdReturnsFalseForZeroId
  Description: Verify that existsById returns false when checking for ID 0L. Since the idGenerator starts at 1, ID 0 should never be assigned to any product.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data.
  Act: Call existsById with ID 0L.
  Assert: Assert that the returned value is false.

Validation:
  This test confirms that edge case IDs that fall outside the normal ID generation range are handled correctly. The AtomicLong idGenerator starts at 1, so 0 is an invalid product ID.

---

Scenario 7: Check if product exists with negative ID

Details:
  TestName: existsByIdReturnsFalseForNegativeId
  Description: Verify that existsById returns false when checking for a negative ID value. Negative IDs are not valid in this repository implementation.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data.
  Act: Call existsById with ID -1L.
  Assert: Assert that the returned value is false.

Validation:
  This test validates boundary conditions by checking negative ID values. Since the idGenerator only produces positive values starting from 1, negative IDs should never exist in the repository.

---

Scenario 8: Check if product exists with maximum Long value

Details:
  TestName: existsByIdReturnsFalseForMaxLongId
  Description: Verify that existsById handles the maximum Long value (Long.MAX_VALUE) correctly and returns false when no such product exists.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data.
  Act: Call existsById with Long.MAX_VALUE.
  Assert: Assert that the returned value is false.

Validation:
  This test ensures the method handles extreme boundary values without errors. It confirms that the ConcurrentHashMap lookup works correctly even with very large ID values.

---

Scenario 9: Check existence of multiple products in sequence

Details:
  TestName: existsByIdReturnsCorrectResultsForMultipleProducts
  Description: Verify that existsById correctly identifies multiple existing products when called in sequence. This tests consistency across multiple calls.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data (5 products with IDs 1-5).
  Act: Call existsById for IDs 1L, 2L, 3L, 4L, and 5L in sequence.
  Assert: Assert that all five calls return true.

Validation:
  This test verifies that the method consistently returns correct results across multiple invocations. It ensures the repository maintains its state correctly and the containsKey operation is reliable.

---

Scenario 10: Check if product exists in empty repository after clearing

Details:
  TestName: existsByIdReturnsFalseAfterAllProductsDeleted
  Description: Verify that existsById returns false for any ID after all products have been deleted from the repository.

Execution:
  Arrange: Create a new ProductRepository instance. Delete all default products by calling deleteById for IDs 1L through 5L.
  Act: Call existsById with ID 1L.
  Assert: Assert that the returned value is false.

Validation:
  This test confirms that the repository correctly reports no products exist after all have been removed. It validates the integrity of the delete operation and the accuracy of existence checks on an emptied repository.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryExistsByIdTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForExistingProduct() {
		// Arrange - repository is initialized with sample products (IDs 1-5) in
		// constructor
		// Act
		boolean result = productRepository.existsById(1L);
		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNonExistingProduct() {
		// Arrange - repository is initialized with sample products (IDs 1-5) in
		// constructor
		// Act
		boolean result = productRepository.existsById(100L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNullId() {
		// Arrange - repository is initialized with sample products in constructor
		// Act & Assert
		assertThrows(NullPointerException.class, () -> productRepository.existsById(null));
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsTrueAfterSavingNewProduct() {
		// Arrange
		Product newProduct = new Product("Test Product", "Test Description", new BigDecimal("50.00"), 10);
		Product savedProduct = productRepository.save(newProduct);
		// Act
		boolean result = productRepository.existsById(savedProduct.getId());
		// Assert
		assertTrue(result);
		assertNotNull(savedProduct.getId());
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterDeletion() {
		// Arrange
		assertTrue(productRepository.existsById(1L)); // Confirm product exists initially
		productRepository.deleteById(1L);
		// Act
		boolean result = productRepository.existsById(1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForZeroId() {
		// Arrange - repository is initialized with sample products in constructor
		// Act
		boolean result = productRepository.existsById(0L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForNegativeId() {
		// Arrange - repository is initialized with sample products in constructor
		// Act
		boolean result = productRepository.existsById(-1L);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForMaxLongId() {
		// Arrange - repository is initialized with sample products in constructor
		// Act
		boolean result = productRepository.existsById(Long.MAX_VALUE);
		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsCorrectResultsForMultipleProducts() {
		// Arrange - repository is initialized with sample products (IDs 1-5) in
		// constructor
		// Act & Assert
		assertTrue(productRepository.existsById(1L));
		assertTrue(productRepository.existsById(2L));
		assertTrue(productRepository.existsById(3L));
		assertTrue(productRepository.existsById(4L));
		assertTrue(productRepository.existsById(5L));
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterAllProductsDeleted() {
		// Arrange - delete all default products
		productRepository.deleteById(1L);
		productRepository.deleteById(2L);
		productRepository.deleteById(3L);
		productRepository.deleteById(4L);
		productRepository.deleteById(5L);
		// Act
		boolean result = productRepository.existsById(1L);
		// Assert
		assertFalse(result);
		assertEquals(0, productRepository.count());
	}

}