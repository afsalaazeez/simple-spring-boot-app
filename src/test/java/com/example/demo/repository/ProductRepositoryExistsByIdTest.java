
// ********RoostGPT********
/*
Test generated by RoostGPT for test dec-1-java using AI Type Claude AI and AI Model claude-opus-4-5-20251101

ROOST_METHOD_HASH=existsById_9b21d91b5f
ROOST_METHOD_SIG_HASH=existsById_83b9bf1592

Scenario 1: Check if an existing product ID returns true

Details:
  TestName: existsByIdReturnsTrueForExistingProduct
  Description: Verify that the existsById method returns true when checking for a product ID that exists in the repository. The repository is initialized with sample data, so existing IDs should be found.

Execution:
  Arrange: Create a new ProductRepository instance which automatically initializes with sample products (IDs 1-5).
  Act: Call existsById with an ID that exists in the repository (e.g., 1L).
  Assert: Assert that the returned value is true.

Validation:
  The assertion verifies that the method correctly identifies an existing product in the ConcurrentHashMap. This is important for business logic that needs to validate product existence before performing operations like updates or retrievals.

---

Scenario 2: Check if a non-existing product ID returns false

Details:
  TestName: existsByIdReturnsFalseForNonExistingProduct
  Description: Verify that the existsById method returns false when checking for a product ID that does not exist in the repository.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data.
  Act: Call existsById with an ID that does not exist (e.g., 999L).
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that the method correctly returns false for non-existing IDs. This is crucial for preventing operations on non-existent products and for proper error handling in the application.

---

Scenario 3: Check existsById with null ID parameter

Details:
  TestName: existsByIdWithNullIdReturnsFalse
  Description: Verify the behavior of existsById when a null value is passed as the ID parameter. ConcurrentHashMap's containsKey method does not accept null keys and will throw a NullPointerException.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Call existsById with null as the parameter.
  Assert: Assert that a NullPointerException is thrown.

Validation:
  This test validates the edge case behavior when null is passed. Since ConcurrentHashMap does not allow null keys, understanding this behavior is important for proper input validation in calling code.

---

Scenario 4: Check existsById with ID zero

Details:
  TestName: existsByIdWithZeroIdReturnsFalse
  Description: Verify that existsById returns false when checking for ID 0, which is not a valid product ID since the idGenerator starts at 1.

Execution:
  Arrange: Create a new ProductRepository instance with default initialization.
  Act: Call existsById with 0L as the parameter.
  Assert: Assert that the returned value is false.

Validation:
  The assertion confirms that zero is not a valid product ID in the system. Since the AtomicLong idGenerator starts at 1, no product should ever have ID 0, making this an important boundary test.

---

Scenario 5: Check existsById with negative ID

Details:
  TestName: existsByIdWithNegativeIdReturnsFalse
  Description: Verify that existsById returns false when checking for a negative ID value, which should never exist in the repository.

Execution:
  Arrange: Create a new ProductRepository instance.
  Act: Call existsById with a negative value (e.g., -1L).
  Assert: Assert that the returned value is false.

Validation:
  This test ensures that negative IDs are handled correctly. Since the idGenerator only produces positive values, negative IDs should never exist, and the method should return false.

---

Scenario 6: Check existsById after deleting a product

Details:
  TestName: existsByIdReturnsFalseAfterProductDeletion
  Description: Verify that existsById returns false for a product ID after that product has been deleted from the repository.

Execution:
  Arrange: Create a new ProductRepository instance. Confirm that product with ID 1L exists by calling existsById. Then delete the product using deleteById(1L).
  Act: Call existsById with 1L after deletion.
  Assert: Assert that the returned value is false.

Validation:
  This test verifies the consistency between delete and exists operations. It ensures that once a product is removed, the existsById method correctly reflects the updated state of the repository.

---

Scenario 7: Check existsById for a newly saved product

Details:
  TestName: existsByIdReturnsTrueForNewlySavedProduct
  Description: Verify that existsById returns true for a product that was just saved to the repository.

Execution:
  Arrange: Create a new ProductRepository instance. Create a new Product with name "Test Product", description "Test Description", price BigDecimal("50.00"), and quantity 10. Save the product using the save method and capture the returned product with its assigned ID.
  Act: Call existsById with the ID of the newly saved product.
  Assert: Assert that the returned value is true.

Validation:
  This test confirms that the save operation correctly adds products to the internal map and that existsById can immediately find newly added products. This is essential for verifying data persistence consistency.

---

Scenario 8: Check existsById with Long.MAX_VALUE

Details:
  TestName: existsByIdWithMaxLongValueReturnsFalse
  Description: Verify that existsById handles the maximum Long value correctly and returns false when no product with that ID exists.

Execution:
  Arrange: Create a new ProductRepository instance with default sample data.
  Act: Call existsById with Long.MAX_VALUE.
  Assert: Assert that the returned value is false.

Validation:
  This boundary test ensures that the method handles extreme Long values without errors. It verifies that the ConcurrentHashMap lookup works correctly with large ID values.

---

Scenario 9: Check existsById for all initially seeded products

Details:
  TestName: existsByIdReturnsTrueForAllSeededProducts
  Description: Verify that existsById returns true for all five products that are seeded during repository initialization (IDs 1 through 5).

Execution:
  Arrange: Create a new ProductRepository instance which seeds 5 products.
  Act: Call existsById for each ID from 1L to 5L.
  Assert: Assert that all five calls return true.

Validation:
  This test validates that the constructor properly initializes all sample products and that they are all accessible via existsById. It ensures the integrity of the initial data seeding process.

---

Scenario 10: Check existsById for ID just beyond seeded range

Details:
  TestName: existsByIdReturnsFalseForIdBeyondSeededRange
  Description: Verify that existsById returns false for ID 6, which is the first ID beyond the initially seeded products (1-5).

Execution:
  Arrange: Create a new ProductRepository instance with default 5 seeded products.
  Act: Call existsById with 6L.
  Assert: Assert that the returned value is false.

Validation:
  This boundary test confirms that the method correctly distinguishes between existing and non-existing IDs at the boundary of seeded data. It validates that no extra products are inadvertently created during initialization.

*/

// ********RoostGPT********

package com.example.demo.repository;

import com.example.demo.model.Product;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import java.math.BigDecimal;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.*;
import org.springframework.stereotype.Repository;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

class ProductRepositoryExistsByIdTest {

	private ProductRepository productRepository;

	@BeforeEach
	void setUp() {
		productRepository = new ProductRepository();
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForExistingProduct() {
		// Arrange - repository is initialized with sample products (IDs 1-5)

		// Act
		boolean result = productRepository.existsById(1L);

		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdReturnsFalseForNonExistingProduct() {
		// Arrange - repository is initialized with default sample data

		// Act
		boolean result = productRepository.existsById(999L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("invalid")
	void existsByIdWithNullIdReturnsFalse() {
		// Arrange

		// Act & Assert
		assertThrows(NullPointerException.class, () -> productRepository.existsById(null));
	}

	@Test
	@Tag("boundary")
	void existsByIdWithZeroIdReturnsFalse() {
		// Arrange - repository is initialized with default initialization

		// Act
		boolean result = productRepository.existsById(0L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithNegativeIdReturnsFalse() {
		// Arrange

		// Act
		boolean result = productRepository.existsById(-1L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsFalseAfterProductDeletion() {
		// Arrange
		assertTrue(productRepository.existsById(1L));
		productRepository.deleteById(1L);

		// Act
		boolean result = productRepository.existsById(1L);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("integration")
	void existsByIdReturnsTrueForNewlySavedProduct() {
		// Arrange
		Product newProduct = new Product("Test Product", "Test Description", new BigDecimal("50.00"), 10);
		Product savedProduct = productRepository.save(newProduct);

		// Act
		boolean result = productRepository.existsById(savedProduct.getId());

		// Assert
		assertTrue(result);
	}

	@Test
	@Tag("boundary")
	void existsByIdWithMaxLongValueReturnsFalse() {
		// Arrange - repository is initialized with default sample data

		// Act
		boolean result = productRepository.existsById(Long.MAX_VALUE);

		// Assert
		assertFalse(result);
	}

	@Test
	@Tag("valid")
	void existsByIdReturnsTrueForAllSeededProducts() {
		// Arrange - repository seeds 5 products

		// Act & Assert
		assertTrue(productRepository.existsById(1L));
		assertTrue(productRepository.existsById(2L));
		assertTrue(productRepository.existsById(3L));
		assertTrue(productRepository.existsById(4L));
		assertTrue(productRepository.existsById(5L));
	}

	@Test
	@Tag("boundary")
	void existsByIdReturnsFalseForIdBeyondSeededRange() {
		// Arrange - repository is initialized with default 5 seeded products

		// Act
		boolean result = productRepository.existsById(6L);

		// Assert
		assertFalse(result);
	}

}